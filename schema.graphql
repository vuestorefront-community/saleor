# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

interface Job {
    "Created date time of job in ISO 8601 format."
    createdAt: DateTime!
    "Job message."
    message: String
    "Job status."
    status: JobStatusEnum!
    "Date time of job last update in ISO 8601 format."
    updatedAt: DateTime!
}

"An object with an ID"
interface Node {
    "The ID of the object."
    id: ID!
}

interface ObjectWithMetadata {
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
}

union TranslatableItem = AttributeTranslatableContent | AttributeValueTranslatableContent | CategoryTranslatableContent | CollectionTranslatableContent | MenuItemTranslatableContent | PageTranslatableContent | ProductTranslatableContent | ProductVariantTranslatableContent | SaleTranslatableContent | ShippingMethodTranslatableContent | VoucherTranslatableContent

union _Entity = Address | App | Category | Collection | Group | Product | ProductImage | ProductType | ProductVariant | ServiceAccount | User

"Create a new address for the customer."
type AccountAddressCreate {
    accountErrors: [AccountError!]!
    address: Address
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A user instance for which the address was created."
    user: User
}

"Delete an address of the logged-in user."
type AccountAddressDelete {
    accountErrors: [AccountError!]!
    address: Address
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A user instance for which the address was deleted."
    user: User
}

"Updates an address of the logged-in user."
type AccountAddressUpdate {
    accountErrors: [AccountError!]!
    address: Address
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A user object for which the address was edited."
    user: User
}

"Remove user account."
type AccountDelete {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

type AccountError {
    "The error code."
    code: AccountErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Register a new user."
type AccountRegister {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Informs whether users need to confirm their email address."
    requiresConfirmation: Boolean
    user: User
}

"Sends an email with the account removal link for the logged-in user."
type AccountRequestDeletion {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Sets a default address for the authenticated user."
type AccountSetDefaultAddress {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "An updated user instance."
    user: User
}

"Updates the account of the logged-in user."
type AccountUpdate {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

"Updates metadata of the logged-in user."
type AccountUpdateMeta {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

"Represents user address data."
type Address implements Node {
    city: String!
    cityArea: String!
    companyName: String!
    "Shop's default country."
    country: CountryDisplay!
    countryArea: String!
    firstName: String!
    "The ID of the object."
    id: ID!
    "Address is user's default billing address."
    isDefaultBillingAddress: Boolean
    "Address is user's default shipping address."
    isDefaultShippingAddress: Boolean
    lastName: String!
    phone: String
    postalCode: String!
    streetAddress1: String!
    streetAddress2: String!
}

"Creates user address."
type AddressCreate {
    accountErrors: [AccountError!]!
    address: Address
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A user instance for which the address was created."
    user: User
}

"Deletes an address."
type AddressDelete {
    accountErrors: [AccountError!]!
    address: Address
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A user instance for which the address was deleted."
    user: User
}

"Sets a default address for the given user."
type AddressSetDefault {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "An updated user instance."
    user: User
}

"Updates an address."
type AddressUpdate {
    accountErrors: [AccountError!]!
    address: Address
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A user object for which the address was edited."
    user: User
}

type AddressValidationData {
    addressFormat: String
    addressLatinFormat: String
    allowedFields: [String]
    cityAreaChoices: [ChoiceValue]
    cityAreaType: String
    cityChoices: [ChoiceValue]
    cityType: String
    countryAreaChoices: [ChoiceValue]
    countryAreaType: String
    countryCode: String
    countryName: String
    postalCodeExamples: [String]
    postalCodeMatchers: [String]
    postalCodePrefix: String
    postalCodeType: String
    requiredFields: [String]
    upperFields: [String]
}

"Represents allocation."
type Allocation implements Node {
    "The ID of the object."
    id: ID!
    "Quantity allocated for orders."
    quantity: Int!
    "The warehouse were items were allocated."
    warehouse: Warehouse!
}

"Represents app data."
type App implements Node & ObjectWithMetadata {
    "Description of this app."
    aboutApp: String
    "JWT token used to authenticate by thridparty app."
    accessToken: String
    "Url to iframe with the app."
    appUrl: String
    "Url to iframe with the configuration for the app."
    configurationUrl: String
    "The date and time when the app was created."
    created: DateTime
    "Description of the data privacy defined for this app."
    dataPrivacy: String
    "Url to details about the privacy policy on the app owner page."
    dataPrivacyUrl: String
    "Homepage of the app."
    homepageUrl: String
    "The ID of the object."
    id: ID!
    "Determine if app will be set active or not."
    isActive: Boolean
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "Name of the app."
    name: String
    "List of the app's permissions."
    permissions: [Permission]
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Support page for the app."
    supportUrl: String
    "Last 4 characters of the tokens."
    tokens: [AppToken]
    "Type of the app."
    type: AppTypeEnum
    "Version number of the app."
    version: String
    "List of webhooks assigned to this app."
    webhooks: [Webhook]
}

"Activate the app."
type AppActivate {
    app: App
    appErrors: [AppError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

type AppCountableConnection {
    edges: [AppCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type AppCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: App!
}

"Creates a new app."
type AppCreate {
    app: App
    appErrors: [AppError!]!
    "The newly created authentication token."
    authToken: String
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Deactivate the app."
type AppDeactivate {
    app: App
    appErrors: [AppError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Deletes an app."
type AppDelete {
    app: App
    appErrors: [AppError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Delete failed installation."
type AppDeleteFailedInstallation {
    appErrors: [AppError!]!
    appInstallation: AppInstallation
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

type AppError {
    "The error code."
    code: AppErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of permissions which causes the error."
    permissions: [PermissionEnum!]
}

"Fetch and validate manifest."
type AppFetchManifest {
    appErrors: [AppError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    manifest: Manifest
}

"Install new app by using app manifest."
type AppInstall {
    appErrors: [AppError!]!
    appInstallation: AppInstallation
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Represents ongoing installation of app."
type AppInstallation implements Job & Node {
    appName: String!
    "Created date time of job in ISO 8601 format."
    createdAt: DateTime!
    "The ID of the object."
    id: ID!
    manifestUrl: String!
    "Job message."
    message: String
    "Job status."
    status: JobStatusEnum!
    "Date time of job last update in ISO 8601 format."
    updatedAt: DateTime!
}

"Retry failed installation of new app."
type AppRetryInstall {
    appErrors: [AppError!]!
    appInstallation: AppInstallation
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Represents token data."
type AppToken implements Node {
    "Last 4 characters of the token."
    authToken: String
    "The ID of the object."
    id: ID!
    "Name of the authenticated token."
    name: String
}

"Creates a new token."
type AppTokenCreate {
    appErrors: [AppError!]!
    appToken: AppToken
    "The newly created authentication token."
    authToken: String
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Deletes an authentication token assigned to app."
type AppTokenDelete {
    appErrors: [AppError!]!
    appToken: AppToken
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Verify provided app token."
type AppTokenVerify {
    appErrors: [AppError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Determine if token is valid or not."
    valid: Boolean!
}

"Updates an existing app."
type AppUpdate {
    app: App
    appErrors: [AppError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Assigns storefront's navigation menus."
type AssignNavigation {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Assigned navigation menu."
    menu: Menu
    menuErrors: [MenuError!]!
}

"Custom attribute of a product. Attributes can be assigned to products and variants at the product type level."
type Attribute implements Node & ObjectWithMetadata {
    "Whether the attribute can be displayed in the admin product list."
    availableInGrid: Boolean!
    "Whether the attribute can be filtered in dashboard."
    filterableInDashboard: Boolean!
    "Whether the attribute can be filtered in storefront."
    filterableInStorefront: Boolean!
    "The ID of the object."
    id: ID!
    "The input type to use for entering attribute values in the dashboard."
    inputType: AttributeInputTypeEnum
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "Name of an attribute displayed in the interface."
    name: String
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    productTypes(after: String, before: String, first: Int, last: Int): ProductTypeCountableConnection!
    productVariantTypes(after: String, before: String, first: Int, last: Int): ProductTypeCountableConnection!
    "Internal representation of an attribute name."
    slug: String
    "The position of the attribute in the storefront navigation (0 by default)."
    storefrontSearchPosition: Int!
    "Returns translated attribute fields for the given language code."
    translation(
        "A language code to return the translation for attribute."
        languageCode: LanguageCodeEnum!
    ): AttributeTranslation
    "Whether the attribute requires values to be passed or not."
    valueRequired: Boolean!
    "List of attribute's values."
    values: [AttributeValue]
    "Whether the attribute should be visible or not in storefront."
    visibleInStorefront: Boolean!
}

"Assign attributes to a given product type."
type AttributeAssign {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    "The updated product type."
    productType: ProductType
}

"Deletes attributes."
type AttributeBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Clears public metadata item for attribute."
type AttributeClearMeta {
    attribute: Attribute
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Clears public metadata item for attribute."
type AttributeClearPrivateMeta {
    attribute: Attribute
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

type AttributeCountableConnection {
    edges: [AttributeCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type AttributeCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Attribute!
}

"Creates an attribute."
type AttributeCreate {
    attribute: Attribute
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Deletes an attribute."
type AttributeDelete {
    attribute: Attribute
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Reorder the values of an attribute."
type AttributeReorderValues {
    "Attribute from which values are reordered."
    attribute: Attribute
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

type AttributeTranslatableContent implements Node {
    "Custom attribute of a product."
    attribute: Attribute
    "The ID of the object."
    id: ID!
    name: String!
    "Returns translated attribute fields for the given language code."
    translation(
        "A language code to return the translation for attribute."
        languageCode: LanguageCodeEnum!
    ): AttributeTranslation
}

"Creates/Updates translations for attribute."
type AttributeTranslate {
    attribute: Attribute
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    translationErrors: [TranslationError!]!
}

type AttributeTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

"Un-assign attributes from a given product type."
type AttributeUnassign {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    "The updated product type."
    productType: ProductType
}

"Updates attribute."
type AttributeUpdate {
    attribute: Attribute
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Update public metadata for attribute."
type AttributeUpdateMeta {
    attribute: Attribute
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Update public metadata for attribute."
type AttributeUpdatePrivateMeta {
    attribute: Attribute
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Represents a value of an attribute."
type AttributeValue implements Node {
    "The ID of the object."
    id: ID!
    "The input type to use for entering attribute values in the dashboard."
    inputType: AttributeInputTypeEnum
    "Name of a value displayed in the interface."
    name: String
    "Internal representation of a value (unique per attribute)."
    slug: String
    "Returns translated attribute value fields for the given language code."
    translation(
        "A language code to return the translation for attribute value."
        languageCode: LanguageCodeEnum!
    ): AttributeValueTranslation
    "Type of value (used only when `value` field is set)."
    type: AttributeValueType @deprecated(reason : "Use the `inputType` field to determine the type of attribute's value. This field will be removed after 2020-07-31.")
}

"Deletes values of attributes."
type AttributeValueBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Creates a value for an attribute."
type AttributeValueCreate {
    "The updated attribute."
    attribute: Attribute
    attributeValue: AttributeValue
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Deletes a value of an attribute."
type AttributeValueDelete {
    "The updated attribute."
    attribute: Attribute
    attributeValue: AttributeValue
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

type AttributeValueTranslatableContent implements Node {
    "Represents a value of an attribute."
    attributeValue: AttributeValue
    "The ID of the object."
    id: ID!
    name: String!
    "Returns translated attribute value fields for the given language code."
    translation(
        "A language code to return the translation for attribute value."
        languageCode: LanguageCodeEnum!
    ): AttributeValueTranslation
}

"Creates/Updates translations for attribute value."
type AttributeValueTranslate {
    attributeValue: AttributeValue
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    translationErrors: [TranslationError!]!
}

type AttributeValueTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

"Updates value of an attribute."
type AttributeValueUpdate {
    "The updated attribute."
    attribute: Attribute
    attributeValue: AttributeValue
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

type AuthorizationKey {
    "Authorization key (client ID)."
    key: String!
    "Name of the authorization backend."
    name: AuthorizationKeyType!
}

"Adds an authorization key."
type AuthorizationKeyAdd {
    "Newly added authorization key."
    authorizationKey: AuthorizationKey
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]!
}

"Deletes an authorization key."
type AuthorizationKeyDelete {
    "Authorization key that was deleted."
    authorizationKey: AuthorizationKey
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]!
}

type BulkProductError {
    "List of attributes IDs which causes the error."
    attributes: [ID!]
    "The error code."
    code: ProductErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "Index of an input list item that caused the error."
    index: Int
    "The error message."
    message: String
    "List of warehouse IDs which causes the error."
    warehouses: [ID!]
}

type BulkStockError {
    "List of attributes IDs which causes the error."
    attributes: [ID!]
    "The error code."
    code: ProductErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "Index of an input list item that caused the error."
    index: Int
    "The error message."
    message: String
}

"Represents a single category of products. Categories allow to organize products in a tree-hierarchies which can be used for navigation in the storefront."
type Category implements Node & ObjectWithMetadata {
    "List of ancestors of the category."
    ancestors(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    backgroundImage(
        "Size of the image."
        size: Int
    ): Image
    "List of children of the category."
    children(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    level: Int!
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    parent: Category
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of products in the category."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    seoDescription: String
    seoTitle: String
    slug: String!
    "Returns translated category fields for the given language code."
    translation(
        "A language code to return the translation for category."
        languageCode: LanguageCodeEnum!
    ): CategoryTranslation
    "The storefront's URL for the category."
    url: String @deprecated(reason : "This field will be removed after 2020-07-31.")
}

"Deletes categories."
type CategoryBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Clears public metadata for category."
type CategoryClearMeta {
    category: Category
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Clears private metadata for category."
type CategoryClearPrivateMeta {
    category: Category
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

type CategoryCountableConnection {
    edges: [CategoryCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CategoryCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Category!
}

"Creates a new category."
type CategoryCreate {
    category: Category
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Deletes a category."
type CategoryDelete {
    category: Category
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

type CategoryTranslatableContent implements Node {
    "Represents a single category of products."
    category: Category
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    name: String!
    seoDescription: String
    seoTitle: String
    "Returns translated category fields for the given language code."
    translation(
        "A language code to return the translation for category."
        languageCode: LanguageCodeEnum!
    ): CategoryTranslation
}

"Creates/Updates translations for Category."
type CategoryTranslate {
    category: Category
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    translationErrors: [TranslationError!]!
}

type CategoryTranslation implements Node {
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
    seoDescription: String
    seoTitle: String
}

"Updates a category."
type CategoryUpdate {
    category: Category
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Update public metadata for category."
type CategoryUpdateMeta {
    category: Category
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Update private metadata for category."
type CategoryUpdatePrivateMeta {
    category: Category
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Checkout object."
type Checkout implements Node & ObjectWithMetadata {
    "List of available payment gateways."
    availablePaymentGateways: [PaymentGateway!]!
    "Shipping methods that can be used with this order."
    availableShippingMethods: [ShippingMethod]!
    billingAddress: Address
    created: DateTime!
    discount: Money
    discountName: String
    "Email of a customer."
    email: String!
    "List of gift cards associated with this checkout."
    giftCards: [GiftCard]
    "The ID of the object."
    id: ID!
    "Returns True, if checkout requires shipping."
    isShippingRequired: Boolean!
    lastChange: DateTime!
    "A list of checkout lines, each containing information about an item in the checkout."
    lines: [CheckoutLine]
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    note: String!
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    quantity: Int!
    shippingAddress: Address
    shippingMethod: ShippingMethod
    "The price of the shipping, with all the taxes included."
    shippingPrice: TaxedMoney
    "The price of the checkout before shipping, with taxes included."
    subtotalPrice: TaxedMoney
    "The checkout's token."
    token: UUID!
    "The sum of the the checkout line prices, with all the taxes,shipping costs, and discounts included."
    totalPrice: TaxedMoney
    translatedDiscountName: String
    user: User
    voucherCode: String
}

"Adds a gift card or a voucher to a checkout."
type CheckoutAddPromoCode {
    "The checkout with the added gift card or voucher."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Update billing address in the existing checkout."
type CheckoutBillingAddressUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Clear metadata for checkout."
type CheckoutClearMeta {
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Clear private metadata for checkout."
type CheckoutClearPrivateMeta {
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Completes the checkout. As a result a new order is created and a payment charge is made. This action requires a successful payment before it can be performed. In case additional confirmation step as 3D secure is required confirmationNeeded flag will be set to True and no order created until payment is confirmed with second call of this mutation."
type CheckoutComplete {
    checkoutErrors: [CheckoutError!]!
    "Confirmation data used to process additional authorization steps."
    confirmationData: JSONString
    "Set to true if payment needs to be confirmed before checkout is complete."
    confirmationNeeded: Boolean!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Placed order."
    order: Order
}

type CheckoutCountableConnection {
    edges: [CheckoutCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CheckoutCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Checkout!
}

"Create a new checkout."
type CheckoutCreate {
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "Whether the checkout was created or the current active one was returned. Refer to checkoutLinesAdd and checkoutLinesUpdate to merge a cart with an active checkout."
    created: Boolean
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Sets the customer as the owner of the checkout."
type CheckoutCustomerAttach {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Removes the user assigned as the owner of the checkout."
type CheckoutCustomerDetach {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Updates email address in the existing checkout object."
type CheckoutEmailUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

type CheckoutError {
    "The error code."
    code: CheckoutErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of varint IDs which causes the error."
    variants: [ID!]
}

"Represents an item in the checkout."
type CheckoutLine implements Node {
    "The ID of the object."
    id: ID!
    quantity: Int!
    "Indicates whether the item need to be delivered."
    requiresShipping: Boolean
    "The sum of the checkout line price, taxes and discounts."
    totalPrice: TaxedMoney
    variant: ProductVariant!
}

type CheckoutLineCountableConnection {
    edges: [CheckoutLineCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CheckoutLineCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: CheckoutLine!
}

"Deletes a CheckoutLine."
type CheckoutLineDelete {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Adds a checkout line to the existing checkout."
type CheckoutLinesAdd {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Updates checkout line in the existing checkout."
type CheckoutLinesUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Create a new payment for given checkout."
type CheckoutPaymentCreate {
    "Related checkout object."
    checkout: Checkout
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A newly created payment."
    payment: Payment
    paymentErrors: [PaymentError!]!
}

"Remove a gift card or a voucher from a checkout."
type CheckoutRemovePromoCode {
    "The checkout with the removed gift card or voucher."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Update shipping address in the existing checkout."
type CheckoutShippingAddressUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Updates the shipping address of the checkout."
type CheckoutShippingMethodUpdate {
    "An updated checkout."
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Updates metadata for checkout."
type CheckoutUpdateMeta {
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Updates private metadata for checkout."
type CheckoutUpdatePrivateMeta {
    checkout: Checkout
    checkoutErrors: [CheckoutError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

type ChoiceValue {
    raw: String
    verbose: String
}

"Represents a collection of products."
type Collection implements Node & ObjectWithMetadata {
    backgroundImage(
        "Size of the image."
        size: Int
    ): Image
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "Whether the collection is published."
    isPublished: Boolean!
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of products in this collection."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for products."
        filter: ProductFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort products."
        sortBy: ProductOrder
    ): ProductCountableConnection
    publicationDate: Date
    seoDescription: String
    seoTitle: String
    slug: String!
    "Returns translated collection fields for the given language code."
    translation(
        "A language code to return the translation for collection."
        languageCode: LanguageCodeEnum!
    ): CollectionTranslation
}

"Adds products to a collection."
type CollectionAddProducts {
    "Collection to which products will be added."
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Deletes collections."
type CollectionBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Publish collections."
type CollectionBulkPublish {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Clears public metadata for collection."
type CollectionClearMeta {
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Clears private metadata item for collection."
type CollectionClearPrivateMeta {
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

type CollectionCountableConnection {
    edges: [CollectionCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type CollectionCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Collection!
}

"Creates a new collection."
type CollectionCreate {
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Deletes a collection."
type CollectionDelete {
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Remove products from a collection."
type CollectionRemoveProducts {
    "Collection from which products will be removed."
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Reorder the products of a collection."
type CollectionReorderProducts {
    "Collection from which products are reordered."
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

type CollectionTranslatableContent implements Node {
    "Represents a collection of products."
    collection: Collection
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    name: String!
    seoDescription: String
    seoTitle: String
    "Returns translated collection fields for the given language code."
    translation(
        "A language code to return the translation for collection."
        languageCode: LanguageCodeEnum!
    ): CollectionTranslation
}

"Creates/Updates translations for collection."
type CollectionTranslate {
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    translationErrors: [TranslationError!]!
}

type CollectionTranslation implements Node {
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
    seoDescription: String
    seoTitle: String
}

"Updates a collection."
type CollectionUpdate {
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Update public metadata for collection."
type CollectionUpdateMeta {
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Update private metadata for collection."
type CollectionUpdatePrivateMeta {
    collection: Collection
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Stores information about a single configuration field."
type ConfigurationItem {
    "Help text for the field."
    helpText: String
    "Label for the field."
    label: String
    "Name of the field."
    name: String!
    "Type of the field."
    type: ConfigurationTypeFieldEnum
    "Current value of the field."
    value: String
}

"Confirm user account with token sent by email during registration."
type ConfirmAccount {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "An activated user account."
    user: User
}

"Confirm the email change of the logged-in user."
type ConfirmEmailChange {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A user instance with a new email."
    user: User
}

type CountryDisplay {
    "Country code."
    code: String!
    "Country name."
    country: String!
    "Country tax."
    vat: VAT
}

"Create JWT token."
type CreateToken {
    accountErrors: [AccountError!]!
    "CSRF token required to re-generate access token."
    csrfToken: String
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "JWT refresh token, required to re-generate access token."
    refreshToken: String
    "JWT token, required to authenticate."
    token: String
    "A user instance."
    user: User
}

type CreditCard {
    "Card brand."
    brand: String!
    "Two-digit number representing the cards expiration month."
    expMonth: Int
    "Four-digit number representing the cards expiration year."
    expYear: Int
    "First 4 digits of the card number."
    firstDigits: String
    "Last 4 digits of the card number."
    lastDigits: String!
}

"Deletes customers."
type CustomerBulkDelete {
    accountErrors: [AccountError!]!
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Creates a new customer."
type CustomerCreate {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

"Deletes a customer."
type CustomerDelete {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

"History log of the customer."
type CustomerEvent implements Node {
    "Number of objects concerned by the event."
    count: Int
    "Date when event happened at in ISO 8601 format."
    date: DateTime
    "The ID of the object."
    id: ID!
    "Content of the event."
    message: String
    "The concerned order."
    order: Order
    "The concerned order line."
    orderLine: OrderLine
    "Customer event type."
    type: CustomerEventsEnum
    "User who performed the action."
    user: User
}

"Updates an existing customer."
type CustomerUpdate {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

"Deactivate all JWT tokens of the currently authenticated user."
type DeactivateAllUserTokens {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Delete metadata of an object."
type DeleteMetadata {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    item: ObjectWithMetadata
    metadataErrors: [MetadataError!]!
}

"Delete object's private metadata."
type DeletePrivateMetadata {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    item: ObjectWithMetadata
    metadataErrors: [MetadataError!]!
}

type DigitalContent implements Node & ObjectWithMetadata {
    automaticFulfillment: Boolean!
    contentFile: String!
    "The ID of the object."
    id: ID!
    maxDownloads: Int
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    productVariant: ProductVariant!
    urlValidDays: Int
    "List of URLs for the digital variant."
    urls: [DigitalContentUrl]
    useDefaultSettings: Boolean!
}

type DigitalContentCountableConnection {
    edges: [DigitalContentCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type DigitalContentCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: DigitalContent!
}

"Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
type DigitalContentCreate {
    content: DigitalContent
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    variant: ProductVariant
}

"Remove digital content assigned to given variant."
type DigitalContentDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    variant: ProductVariant
}

"Update digital content."
type DigitalContentUpdate {
    content: DigitalContent
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    variant: ProductVariant
}

type DigitalContentUrl implements Node {
    content: DigitalContent!
    created: DateTime!
    downloadNum: Int!
    "The ID of the object."
    id: ID!
    "UUID of digital content."
    token: UUID!
    "URL for digital content."
    url: String
}

"Generate new URL to digital content."
type DigitalContentUrlCreate {
    digitalContentUrl: DigitalContentUrl
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

type DiscountError {
    "The error code."
    code: DiscountErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Represents shop's domain."
type Domain {
    "The host name of the domain."
    host: String!
    "Inform if SSL is enabled."
    sslEnabled: Boolean!
    "Shop's absolute URL."
    url: String!
}

"Deletes draft orders."
type DraftOrderBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    orderErrors: [OrderError!]!
}

"Completes creating an order."
type DraftOrderComplete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Completed order."
    order: Order
    orderErrors: [OrderError!]!
}

"Creates a new draft order."
type DraftOrderCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    order: Order
    orderErrors: [OrderError!]!
}

"Deletes a draft order."
type DraftOrderDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    order: Order
    orderErrors: [OrderError!]!
}

"Deletes an order line from a draft order."
type DraftOrderLineDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A related draft order."
    order: Order
    orderErrors: [OrderError!]!
    "An order line that was deleted."
    orderLine: OrderLine
}

"Updates an order line of a draft order."
type DraftOrderLineUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A related draft order."
    order: Order
    orderErrors: [OrderError!]!
    orderLine: OrderLine
}

"Deletes order lines."
type DraftOrderLinesBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    orderErrors: [OrderError!]!
}

"Create order lines for a draft order."
type DraftOrderLinesCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A related draft order."
    order: Order
    orderErrors: [OrderError!]!
    "List of newly added order lines."
    orderLines: [OrderLine!]
}

"Updates a draft order."
type DraftOrderUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    order: Order
    orderErrors: [OrderError!]!
}

"Represents an error in the input of a mutation."
type Error {
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

type ExportError {
    "The error code."
    code: ExportErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"History log of export file."
type ExportEvent implements Node {
    "App which performed the action."
    app: App
    "Date when event happened at in ISO 8601 format."
    date: DateTime!
    "The ID of the object."
    id: ID!
    "Content of the event."
    message: String!
    "Export event type."
    type: ExportEventsEnum!
    "User who performed the action."
    user: User
}

"Represents a job data of exported file."
type ExportFile implements Job & Node {
    app: App
    "Created date time of job in ISO 8601 format."
    createdAt: DateTime!
    "List of events associated with the export."
    events: [ExportEvent!]
    "The ID of the object."
    id: ID!
    "Job message."
    message: String
    "Job status."
    status: JobStatusEnum!
    "Date time of job last update in ISO 8601 format."
    updatedAt: DateTime!
    "The URL of field to download."
    url: String
    user: User
}

type ExportFileCountableConnection {
    edges: [ExportFileCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ExportFileCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ExportFile!
}

"Export products to csv file."
type ExportProducts {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    exportErrors: [ExportError!]!
    "The newly created export file job which is responsible for export data."
    exportFile: ExportFile
}

"Represents order fulfillment."
type Fulfillment implements Node & ObjectWithMetadata {
    created: DateTime!
    fulfillmentOrder: Int!
    "The ID of the object."
    id: ID!
    "List of lines for the fulfillment."
    lines: [FulfillmentLine]
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    status: FulfillmentStatus!
    "User-friendly fulfillment status."
    statusDisplay: String
    trackingNumber: String!
    "Warehouse from fulfillment was fulfilled."
    warehouse: Warehouse
}

"Cancels existing fulfillment and optionally restocks items."
type FulfillmentCancel {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A canceled fulfillment."
    fulfillment: Fulfillment
    "Order which fulfillment was cancelled."
    order: Order
    orderErrors: [OrderError!]!
}

"Clears metadata for fulfillment."
type FulfillmentClearMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    fulfillment: Fulfillment
}

"Clears private metadata for fulfillment."
type FulfillmentClearPrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    fulfillment: Fulfillment
}

"Represents line of the fulfillment."
type FulfillmentLine implements Node {
    "The ID of the object."
    id: ID!
    orderLine: OrderLine
    quantity: Int!
}

"Updates metadata for fulfillment."
type FulfillmentUpdateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    fulfillment: Fulfillment
}

"Updates metadata for fulfillment."
type FulfillmentUpdatePrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    fulfillment: Fulfillment
}

"Updates a fulfillment for an order."
type FulfillmentUpdateTracking {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A fulfillment with updated tracking."
    fulfillment: Fulfillment
    "Order for which fulfillment was updated."
    order: Order
    orderErrors: [OrderError!]!
}

"Payment gateway client configuration key and value pair."
type GatewayConfigLine {
    "Gateway config key."
    field: String!
    "Gateway config value for key."
    value: String
}

"Represents customers's geolocalization data."
type Geolocalization {
    "Country of the user acquired by his IP address."
    country: CountryDisplay
}

"A gift card is a prepaid electronic payment card accepted in stores. They can be used during checkout by providing a valid gift card codes."
type GiftCard implements Node {
    "Gift card code."
    code: String
    created: DateTime!
    currentBalance: Money
    "Code in format which allows displaying in a user interface."
    displayCode: String
    endDate: Date
    "The ID of the object."
    id: ID!
    initialBalance: Money
    isActive: Boolean!
    lastUsedOn: DateTime
    startDate: Date!
    "The customer who bought a gift card."
    user: User
}

"Activate a gift card."
type GiftCardActivate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A gift card to activate."
    giftCard: GiftCard
    giftCardErrors: [GiftCardError!]!
}

type GiftCardCountableConnection {
    edges: [GiftCardCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type GiftCardCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: GiftCard!
}

"Creates a new gift card."
type GiftCardCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    giftCard: GiftCard
    giftCardErrors: [GiftCardError!]!
}

"Deactivate a gift card."
type GiftCardDeactivate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A gift card to deactivate."
    giftCard: GiftCard
    giftCardErrors: [GiftCardError!]!
}

type GiftCardError {
    "The error code."
    code: GiftCardErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Update a gift card."
type GiftCardUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    giftCard: GiftCard
    giftCardErrors: [GiftCardError!]!
}

"Represents permission group data."
type Group implements Node {
    "The ID of the object."
    id: ID!
    name: String!
    "List of group permissions"
    permissions: [Permission]
    "True, if the currently authenticated user has rights to manage a group."
    userCanManage: Boolean!
    "List of group users"
    users: [User]
}

type GroupCountableConnection {
    edges: [GroupCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type GroupCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Group!
}

"Updates homepage collection of the shop."
type HomepageCollectionUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]!
}

"Represents an image."
type Image {
    "Alt text for an image."
    alt: String
    "The URL of the image."
    url: String!
}

"Represents an Invoice."
type Invoice implements Job & Node & ObjectWithMetadata {
    "Created date time of job in ISO 8601 format."
    createdAt: DateTime!
    externalUrl: String
    "The ID of the object."
    id: ID!
    "Job message."
    message: String
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    number: String
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Job status."
    status: JobStatusEnum!
    "Date time of job last update in ISO 8601 format."
    updatedAt: DateTime!
    "URL to download an invoice."
    url: String
}

"Creates a ready to send invoice."
type InvoiceCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    invoice: Invoice
    invoiceErrors: [InvoiceError!]!
}

"Deletes an invoice."
type InvoiceDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    invoice: Invoice
    invoiceErrors: [InvoiceError!]!
}

type InvoiceError {
    "The error code."
    code: InvoiceErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Request an invoice for the order using plugin."
type InvoiceRequest {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    invoice: Invoice
    invoiceErrors: [InvoiceError!]!
    "Order related to an invoice."
    order: Order
}

"Requests deletion of an invoice."
type InvoiceRequestDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    invoice: Invoice
    invoiceErrors: [InvoiceError!]!
}

"Send an invoice by email."
type InvoiceSendEmail {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    invoice: Invoice
    invoiceErrors: [InvoiceError!]!
}

"Updates an invoice."
type InvoiceUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    invoice: Invoice
    invoiceErrors: [InvoiceError!]!
}

type LanguageDisplay {
    "ISO 639 representation of the language name."
    code: LanguageCodeEnum!
    "Full name of the language."
    language: String!
}

"The manifest definition."
type Manifest {
    about: String
    appUrl: String
    configurationUrl: String
    dataPrivacy: String
    dataPrivacyUrl: String
    homepageUrl: String
    identifier: String!
    name: String!
    permissions: [Permission]
    supportUrl: String
    tokenTargetUrl: String
    version: String!
}

type Margin {
    start: Int
    stop: Int
}

"Represents a single menu - an object that is used to help navigate through the store."
type Menu implements Node {
    "The ID of the object."
    id: ID!
    items: [MenuItem]
    name: String!
    slug: String!
}

"Deletes menus."
type MenuBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    menuErrors: [MenuError!]!
}

type MenuCountableConnection {
    edges: [MenuCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type MenuCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Menu!
}

"Creates a new Menu."
type MenuCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    menu: Menu
    menuErrors: [MenuError!]!
}

"Deletes a menu."
type MenuDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    menu: Menu
    menuErrors: [MenuError!]!
}

type MenuError {
    "The error code."
    code: MenuErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Represents a single item of the related menu. Can store categories, collection or pages."
type MenuItem implements Node {
    category: Category
    children: [MenuItem]
    collection: Collection
    "The ID of the object."
    id: ID!
    level: Int!
    menu: Menu!
    name: String!
    page: Page
    parent: MenuItem
    "Returns translated menu item fields for the given language code."
    translation(
        "A language code to return the translation for menu item."
        languageCode: LanguageCodeEnum!
    ): MenuItemTranslation
    "URL to the menu item."
    url: String
}

"Deletes menu items."
type MenuItemBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    menuErrors: [MenuError!]!
}

type MenuItemCountableConnection {
    edges: [MenuItemCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type MenuItemCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: MenuItem!
}

"Creates a new menu item."
type MenuItemCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    menuErrors: [MenuError!]!
    menuItem: MenuItem
}

"Deletes a menu item."
type MenuItemDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    menuErrors: [MenuError!]!
    menuItem: MenuItem
}

"Moves items of menus."
type MenuItemMove {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Assigned menu to move within."
    menu: Menu
    menuErrors: [MenuError!]!
}

type MenuItemTranslatableContent implements Node {
    "The ID of the object."
    id: ID!
    "Represents a single item of the related menu. Can store categories, collection or pages."
    menuItem: MenuItem
    name: String!
    "Returns translated menu item fields for the given language code."
    translation(
        "A language code to return the translation for menu item."
        languageCode: LanguageCodeEnum!
    ): MenuItemTranslation
}

"Creates/Updates translations for Menu Item."
type MenuItemTranslate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    menuItem: MenuItem
    translationErrors: [TranslationError!]!
}

type MenuItemTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

"Updates a menu item."
type MenuItemUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    menuErrors: [MenuError!]!
    menuItem: MenuItem
}

"Updates a menu."
type MenuUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    menu: Menu
    menuErrors: [MenuError!]!
}

type MetaClientStore {
    "Metadata stored for a client."
    metadata: [MetaItem]!
    "Metadata client's name."
    name: String!
}

type MetaItem {
    "Key of a metadata item."
    key: String!
    "Value of a metadata item."
    value: String!
}

type MetaStore {
    "List of clients that stored metadata in a group."
    clients: [MetaClientStore]!
    "Name of metadata client group."
    namespace: String!
}

type MetadataError {
    "The error code."
    code: MetadataErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

type MetadataItem {
    "Key of a metadata item."
    key: String!
    "Value of a metadata item."
    value: String!
}

"Represents amount of money in specific currency."
type Money {
    "Amount of money."
    amount: Float!
    "Currency code."
    currency: String!
    "Money formatted according to the current locale."
    localized: String! @deprecated(reason : "Price formatting according to the current locale should be handled by the frontend client. This field will be removed after 2020-07-31.")
}

"Represents a range of amounts of money."
type MoneyRange {
    "Lower bound of a price range."
    start: Money
    "Upper bound of a price range."
    stop: Money
}

type Mutation {
    "Create a new address for the customer."
    accountAddressCreate(
        "Fields required to create address."
        input: AddressInput!,
        "A type of address. If provided, the new address will be automatically assigned as the customer's default address of that type."
        type: AddressTypeEnum
    ): AccountAddressCreate
    "Delete an address of the logged-in user."
    accountAddressDelete(
        "ID of the address to delete."
        id: ID!
    ): AccountAddressDelete
    "Updates an address of the logged-in user."
    accountAddressUpdate(
        "ID of the address to update."
        id: ID!,
        "Fields required to update the address."
        input: AddressInput!
    ): AccountAddressUpdate
    "Remove user account."
    accountDelete(
        "A one-time token required to remove account. Sent by email using AccountRequestDeletion mutation."
        token: String!
    ): AccountDelete
    "Register a new user."
    accountRegister(
        "Fields required to create a user."
        input: AccountRegisterInput!
    ): AccountRegister
    "Sends an email with the account removal link for the logged-in user."
    accountRequestDeletion(
        "URL of a view where users should be redirected to delete their account. URL in RFC 1808 format."
        redirectUrl: String!
    ): AccountRequestDeletion
    "Sets a default address for the authenticated user."
    accountSetDefaultAddress(
        "ID of the address to set as default."
        id: ID!,
        "The type of address."
        type: AddressTypeEnum!
    ): AccountSetDefaultAddress
    "Updates the account of the logged-in user."
    accountUpdate(
        "Fields required to update the account of the logged-in user."
        input: AccountInput!
    ): AccountUpdate
    "Updates metadata of the logged-in user."
    accountUpdateMeta(
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): AccountUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation. This field will be removed after 2020-07-31.")
    "Creates user address."
    addressCreate(
        "Fields required to create address."
        input: AddressInput!,
        "ID of a user to create address for."
        userId: ID!
    ): AddressCreate
    "Deletes an address."
    addressDelete(
        "ID of the address to delete."
        id: ID!
    ): AddressDelete
    "Sets a default address for the given user."
    addressSetDefault(
        "ID of the address."
        addressId: ID!,
        "The type of address."
        type: AddressTypeEnum!,
        "ID of the user to change the address for."
        userId: ID!
    ): AddressSetDefault
    "Updates an address."
    addressUpdate(
        "ID of the address to update."
        id: ID!,
        "Fields required to update the address."
        input: AddressInput!
    ): AddressUpdate
    "Activate the app."
    appActivate(
        "ID of app to activate."
        id: ID!
    ): AppActivate
    "Creates a new app."
    appCreate(
        "Fields required to create a new app."
        input: AppInput!
    ): AppCreate
    "Deactivate the app."
    appDeactivate(
        "ID of app to deactivate."
        id: ID!
    ): AppDeactivate
    "Deletes an app."
    appDelete(
        "ID of an app to delete."
        id: ID!
    ): AppDelete
    "Delete failed installation."
    appDeleteFailedInstallation(
        "ID of failed installation to delete."
        id: ID!
    ): AppDeleteFailedInstallation
    "Fetch and validate manifest."
    appFetchManifest(manifestUrl: String!): AppFetchManifest
    "Install new app by using app manifest."
    appInstall(
        "Fields required to install a new app."
        input: AppInstallInput!
    ): AppInstall
    "Retry failed installation of new app."
    appRetryInstall(
        "Determine if app will be set active or not."
        activateAfterInstallation: Boolean = true,
        "ID of failed installation."
        id: ID!
    ): AppRetryInstall
    "Creates a new token."
    appTokenCreate(
        "Fields required to create a new auth token."
        input: AppTokenInput!
    ): AppTokenCreate
    "Deletes an authentication token assigned to app."
    appTokenDelete(
        "ID of an auth token to delete."
        id: ID!
    ): AppTokenDelete
    "Verify provided app token."
    appTokenVerify(
        "App token to verify."
        token: String!
    ): AppTokenVerify
    "Updates an existing app."
    appUpdate(
        "ID of an app to update."
        id: ID!,
        "Fields required to update an existing app."
        input: AppInput!
    ): AppUpdate
    "Assigns storefront's navigation menus."
    assignNavigation(
        "ID of the menu."
        menu: ID,
        "Type of the navigation bar to assign the menu to."
        navigationType: NavigationType!
    ): AssignNavigation
    "Add shipping zone to given warehouse."
    assignWarehouseShippingZone(
        "ID of a warehouse to update."
        id: ID!,
        "List of shipping zone IDs."
        shippingZoneIds: [ID!]!
    ): WarehouseShippingZoneAssign
    "Assign attributes to a given product type."
    attributeAssign(
        "The operations to perform."
        operations: [AttributeAssignInput]!,
        "ID of the product type to assign the attributes into."
        productTypeId: ID!
    ): AttributeAssign
    "Deletes attributes."
    attributeBulkDelete(
        "List of attribute IDs to delete."
        ids: [ID]!
    ): AttributeBulkDelete
    "Clears public metadata item for attribute."
    attributeClearMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): AttributeClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Clears public metadata item for attribute."
    attributeClearPrivateMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): AttributeClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Creates an attribute."
    attributeCreate(
        "Fields required to create an attribute."
        input: AttributeCreateInput!
    ): AttributeCreate
    "Deletes an attribute."
    attributeDelete(
        "ID of an attribute to delete."
        id: ID!
    ): AttributeDelete
    "Reorder the values of an attribute."
    attributeReorderValues(
        "ID of an attribute."
        attributeId: ID!,
        "The list of reordering operations for given attribute values."
        moves: [ReorderInput]!
    ): AttributeReorderValues
    "Creates/Updates translations for attribute."
    attributeTranslate(
        "Attribute ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): AttributeTranslate
    "Un-assign attributes from a given product type."
    attributeUnassign(
        "The IDs of the attributes to assign."
        attributeIds: [ID]!,
        "ID of the product type to assign the attributes into."
        productTypeId: ID!
    ): AttributeUnassign
    "Updates attribute."
    attributeUpdate(
        "ID of an attribute to update."
        id: ID!,
        "Fields required to update an attribute."
        input: AttributeUpdateInput!
    ): AttributeUpdate
    "Update public metadata for attribute."
    attributeUpdateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): AttributeUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Update public metadata for attribute."
    attributeUpdatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): AttributeUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Deletes values of attributes."
    attributeValueBulkDelete(
        "List of attribute value IDs to delete."
        ids: [ID]!
    ): AttributeValueBulkDelete
    "Creates a value for an attribute."
    attributeValueCreate(
        "Attribute to which value will be assigned."
        attribute: ID!,
        "Fields required to create an AttributeValue."
        input: AttributeValueCreateInput!
    ): AttributeValueCreate
    "Deletes a value of an attribute."
    attributeValueDelete(
        "ID of a value to delete."
        id: ID!
    ): AttributeValueDelete
    "Creates/Updates translations for attribute value."
    attributeValueTranslate(
        "Attribute Value ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): AttributeValueTranslate
    "Updates value of an attribute."
    attributeValueUpdate(
        "ID of an AttributeValue to update."
        id: ID!,
        "Fields required to update an AttributeValue."
        input: AttributeValueCreateInput!
    ): AttributeValueUpdate
    "Adds an authorization key."
    authorizationKeyAdd(
        "Fields required to create an authorization key."
        input: AuthorizationKeyInput!,
        "Type of an authorization key to add."
        keyType: AuthorizationKeyType!
    ): AuthorizationKeyAdd
    "Deletes an authorization key."
    authorizationKeyDelete(
        "Type of a key to delete."
        keyType: AuthorizationKeyType!
    ): AuthorizationKeyDelete
    "Deletes categories."
    categoryBulkDelete(
        "List of category IDs to delete."
        ids: [ID]!
    ): CategoryBulkDelete
    "Clears public metadata for category."
    categoryClearMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): CategoryClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Clears private metadata for category."
    categoryClearPrivateMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): CategoryClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Creates a new category."
    categoryCreate(
        "Fields required to create a category."
        input: CategoryInput!,
        "ID of the parent category. If empty, category will be top level category."
        parent: ID
    ): CategoryCreate
    "Deletes a category."
    categoryDelete(
        "ID of a category to delete."
        id: ID!
    ): CategoryDelete
    "Creates/Updates translations for Category."
    categoryTranslate(
        "Category ID."
        id: ID!,
        input: TranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): CategoryTranslate
    "Updates a category."
    categoryUpdate(
        "ID of a category to update."
        id: ID!,
        "Fields required to update a category."
        input: CategoryInput!
    ): CategoryUpdate
    "Update public metadata for category."
    categoryUpdateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): CategoryUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Update private metadata for category."
    categoryUpdatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): CategoryUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Adds a gift card or a voucher to a checkout."
    checkoutAddPromoCode(
        "Checkout ID."
        checkoutId: ID!,
        "Gift card code or voucher code."
        promoCode: String!
    ): CheckoutAddPromoCode
    "Update billing address in the existing checkout."
    checkoutBillingAddressUpdate(
        "The billing address of the checkout."
        billingAddress: AddressInput!,
        "ID of the checkout."
        checkoutId: ID!
    ): CheckoutBillingAddressUpdate
    "Clear metadata for checkout."
    checkoutClearMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): CheckoutClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation. This field will be removed after 2020-07-31.")
    "Clear private metadata for checkout."
    checkoutClearPrivateMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): CheckoutClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation. This field will be removed after 2020-07-31.")
    "Completes the checkout. As a result a new order is created and a payment charge is made. This action requires a successful payment before it can be performed. In case additional confirmation step as 3D secure is required confirmationNeeded flag will be set to True and no order created until payment is confirmed with second call of this mutation."
    checkoutComplete(
        "Checkout ID."
        checkoutId: ID!,
        "Client-side generated data required to finalize the payment."
        paymentData: JSONString,
        "URL of a view where users should be redirected to see the order details. URL in RFC 1808 format."
        redirectUrl: String,
        "Determines whether to store the payment source for future usage."
        storeSource: Boolean = false
    ): CheckoutComplete
    "Create a new checkout."
    checkoutCreate(
        "Fields required to create checkout."
        input: CheckoutCreateInput!
    ): CheckoutCreate
    "Sets the customer as the owner of the checkout."
    checkoutCustomerAttach(
        "ID of the checkout."
        checkoutId: ID!,
        "[Deprecated] The ID of the customer. To identify a customer you should authenticate with JWT. This field will be removed after 2020-07-31."
        customerId: ID
    ): CheckoutCustomerAttach
    "Removes the user assigned as the owner of the checkout."
    checkoutCustomerDetach(
        "Checkout ID."
        checkoutId: ID!
    ): CheckoutCustomerDetach
    "Updates email address in the existing checkout object."
    checkoutEmailUpdate(
        "Checkout ID."
        checkoutId: ID,
        "email."
        email: String!
    ): CheckoutEmailUpdate
    "Deletes a CheckoutLine."
    checkoutLineDelete(
        "The ID of the checkout."
        checkoutId: ID!,
        "ID of the checkout line to delete."
        lineId: ID
    ): CheckoutLineDelete
    "Adds a checkout line to the existing checkout."
    checkoutLinesAdd(
        "The ID of the checkout."
        checkoutId: ID!,
        "A list of checkout lines, each containing information about an item in the checkout."
        lines: [CheckoutLineInput]!
    ): CheckoutLinesAdd
    "Updates checkout line in the existing checkout."
    checkoutLinesUpdate(
        "The ID of the checkout."
        checkoutId: ID!,
        "A list of checkout lines, each containing information about an item in the checkout."
        lines: [CheckoutLineInput]!
    ): CheckoutLinesUpdate
    "Create a new payment for given checkout."
    checkoutPaymentCreate(
        "Checkout ID."
        checkoutId: ID!,
        "Data required to create a new payment."
        input: PaymentInput!
    ): CheckoutPaymentCreate
    "Remove a gift card or a voucher from a checkout."
    checkoutRemovePromoCode(
        "Checkout ID."
        checkoutId: ID!,
        "Gift card code or voucher code."
        promoCode: String!
    ): CheckoutRemovePromoCode
    "Update shipping address in the existing checkout."
    checkoutShippingAddressUpdate(
        "ID of the checkout."
        checkoutId: ID!,
        "The mailing address to where the checkout will be shipped."
        shippingAddress: AddressInput!
    ): CheckoutShippingAddressUpdate
    "Updates the shipping address of the checkout."
    checkoutShippingMethodUpdate(
        "Checkout ID."
        checkoutId: ID,
        "Shipping method."
        shippingMethodId: ID!
    ): CheckoutShippingMethodUpdate
    "Updates metadata for checkout."
    checkoutUpdateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): CheckoutUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation. This field will be removed after 2020-07-31.")
    "Updates private metadata for checkout."
    checkoutUpdatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): CheckoutUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation. This field will be removed after 2020-07-31.")
    "Adds products to a collection."
    collectionAddProducts(
        "ID of a collection."
        collectionId: ID!,
        "List of product IDs."
        products: [ID]!
    ): CollectionAddProducts
    "Deletes collections."
    collectionBulkDelete(
        "List of collection IDs to delete."
        ids: [ID]!
    ): CollectionBulkDelete
    "Publish collections."
    collectionBulkPublish(
        "List of collections IDs to (un)publish."
        ids: [ID]!,
        "Determine if collections will be published or not."
        isPublished: Boolean!
    ): CollectionBulkPublish
    "Clears public metadata for collection."
    collectionClearMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): CollectionClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Clears private metadata item for collection."
    collectionClearPrivateMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): CollectionClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Creates a new collection."
    collectionCreate(
        "Fields required to create a collection."
        input: CollectionCreateInput!
    ): CollectionCreate
    "Deletes a collection."
    collectionDelete(
        "ID of a collection to delete."
        id: ID!
    ): CollectionDelete
    "Remove products from a collection."
    collectionRemoveProducts(
        "ID of a collection."
        collectionId: ID!,
        "List of product IDs."
        products: [ID]!
    ): CollectionRemoveProducts
    "Reorder the products of a collection."
    collectionReorderProducts(
        "ID of a collection."
        collectionId: ID!,
        "The collection products position operations."
        moves: [MoveProductInput]!
    ): CollectionReorderProducts
    "Creates/Updates translations for collection."
    collectionTranslate(
        "Collection ID."
        id: ID!,
        input: TranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): CollectionTranslate
    "Updates a collection."
    collectionUpdate(
        "ID of a collection to update."
        id: ID!,
        "Fields required to update a collection."
        input: CollectionInput!
    ): CollectionUpdate
    "Update public metadata for collection."
    collectionUpdateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): CollectionUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Update private metadata for collection."
    collectionUpdatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): CollectionUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Confirm user account with token sent by email during registration."
    confirmAccount(
        "E-mail of the user performing account confirmation."
        email: String!,
        "A one-time token required to confirm the account."
        token: String!
    ): ConfirmAccount
    "Confirm the email change of the logged-in user."
    confirmEmailChange(
        "A one-time token required to change the email."
        token: String!
    ): ConfirmEmailChange
    "Creates new warehouse."
    createWarehouse(
        "Fields required to create warehouse."
        input: WarehouseCreateInput!
    ): WarehouseCreate
    "Deletes customers."
    customerBulkDelete(
        "List of user IDs to delete."
        ids: [ID]!
    ): CustomerBulkDelete
    "Creates a new customer."
    customerCreate(
        "Fields required to create a customer."
        input: UserCreateInput!
    ): CustomerCreate
    "Deletes a customer."
    customerDelete(
        "ID of a customer to delete."
        id: ID!
    ): CustomerDelete
    "Updates an existing customer."
    customerUpdate(
        "ID of a customer to update."
        id: ID!,
        "Fields required to update a customer."
        input: CustomerInput!
    ): CustomerUpdate
    "Delete metadata of an object."
    deleteMetadata(
        "ID of an object to update."
        id: ID!,
        "Metadata keys to delete."
        keys: [String!]!
    ): DeleteMetadata
    "Delete object's private metadata."
    deletePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Metadata keys to delete."
        keys: [String!]!
    ): DeletePrivateMetadata
    "Deletes selected warehouse."
    deleteWarehouse(
        "ID of a warehouse to delete."
        id: ID!
    ): WarehouseDelete
    "Create new digital content. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
    digitalContentCreate(
        "Fields required to create a digital content."
        input: DigitalContentUploadInput!,
        "ID of a product variant to upload digital content."
        variantId: ID!
    ): DigitalContentCreate
    "Remove digital content assigned to given variant."
    digitalContentDelete(
        "ID of a product variant with digital content to remove."
        variantId: ID!
    ): DigitalContentDelete
    "Update digital content."
    digitalContentUpdate(
        "Fields required to update a digital content."
        input: DigitalContentInput!,
        "ID of a product variant with digital content to update."
        variantId: ID!
    ): DigitalContentUpdate
    "Generate new URL to digital content."
    digitalContentUrlCreate(
        "Fields required to create a new url."
        input: DigitalContentUrlCreateInput!
    ): DigitalContentUrlCreate
    "Deletes draft orders."
    draftOrderBulkDelete(
        "List of draft order IDs to delete."
        ids: [ID]!
    ): DraftOrderBulkDelete
    "Completes creating an order."
    draftOrderComplete(
        "ID of the order that will be completed."
        id: ID!
    ): DraftOrderComplete
    "Creates a new draft order."
    draftOrderCreate(
        "Fields required to create an order."
        input: DraftOrderCreateInput!
    ): DraftOrderCreate
    "Deletes a draft order."
    draftOrderDelete(
        "ID of a draft order to delete."
        id: ID!
    ): DraftOrderDelete
    "Deletes an order line from a draft order."
    draftOrderLineDelete(
        "ID of the order line to delete."
        id: ID!
    ): DraftOrderLineDelete
    "Updates an order line of a draft order."
    draftOrderLineUpdate(
        "ID of the order line to update."
        id: ID!,
        "Fields required to update an order line."
        input: OrderLineInput!
    ): DraftOrderLineUpdate
    "Deletes order lines."
    draftOrderLinesBulkDelete(
        "List of order lines IDs to delete."
        ids: [ID]!
    ): DraftOrderLinesBulkDelete
    "Create order lines for a draft order."
    draftOrderLinesCreate(
        "ID of the draft order to add the lines to."
        id: ID!,
        "Fields required to add order lines."
        input: [OrderLineCreateInput]!
    ): DraftOrderLinesCreate
    "Updates a draft order."
    draftOrderUpdate(
        "ID of a draft order to update."
        id: ID!,
        "Fields required to update an order."
        input: DraftOrderInput!
    ): DraftOrderUpdate
    "Export products to csv file."
    exportProducts(
        "Fields required to export product data"
        input: ExportProductsInput!
    ): ExportProducts
    "Activate a gift card."
    giftCardActivate(
        "ID of a gift card to activate."
        id: ID!
    ): GiftCardActivate
    "Creates a new gift card."
    giftCardCreate(
        "Fields required to create a gift card."
        input: GiftCardCreateInput!
    ): GiftCardCreate
    "Deactivate a gift card."
    giftCardDeactivate(
        "ID of a gift card to deactivate."
        id: ID!
    ): GiftCardDeactivate
    "Update a gift card."
    giftCardUpdate(
        "ID of a gift card to update."
        id: ID!,
        "Fields required to update a gift card."
        input: GiftCardUpdateInput!
    ): GiftCardUpdate
    "Updates homepage collection of the shop."
    homepageCollectionUpdate(
        "Collection displayed on homepage."
        collection: ID
    ): HomepageCollectionUpdate
    "Creates a ready to send invoice."
    invoiceCreate(
        "Fields required when creating an invoice."
        input: InvoiceCreateInput!,
        "ID of the order related to invoice."
        orderId: ID!
    ): InvoiceCreate
    "Deletes an invoice."
    invoiceDelete(
        "ID of an invoice to delete."
        id: ID!
    ): InvoiceDelete
    "Request an invoice for the order using plugin."
    invoiceRequest(
        "Invoice number, if not provided it will be generated."
        number: String,
        "ID of the order related to invoice."
        orderId: ID!
    ): InvoiceRequest
    "Requests deletion of an invoice."
    invoiceRequestDelete(
        "ID of an invoice to request the deletion."
        id: ID!
    ): InvoiceRequestDelete
    "Send an invoice by email."
    invoiceSendEmail(
        "ID of an invoice to be sent."
        id: ID!
    ): InvoiceSendEmail
    "Updates an invoice."
    invoiceUpdate(
        "ID of an invoice to update."
        id: ID!,
        "Fields to use when updating an invoice."
        input: UpdateInvoiceInput!
    ): InvoiceUpdate
    "Deletes menus."
    menuBulkDelete(
        "List of menu IDs to delete."
        ids: [ID]!
    ): MenuBulkDelete
    "Creates a new Menu."
    menuCreate(
        "Fields required to create a menu."
        input: MenuCreateInput!
    ): MenuCreate
    "Deletes a menu."
    menuDelete(
        "ID of a menu to delete."
        id: ID!
    ): MenuDelete
    "Deletes menu items."
    menuItemBulkDelete(
        "List of menu item IDs to delete."
        ids: [ID]!
    ): MenuItemBulkDelete
    "Creates a new menu item."
    menuItemCreate(
        "Fields required to update a menu item. Only one of `url`, `category`, `page`, `collection` is allowed per item."
        input: MenuItemCreateInput!
    ): MenuItemCreate
    "Deletes a menu item."
    menuItemDelete(
        "ID of a menu item to delete."
        id: ID!
    ): MenuItemDelete
    "Moves items of menus."
    menuItemMove(
        "ID of the menu."
        menu: ID!,
        "The menu position data."
        moves: [MenuItemMoveInput]!
    ): MenuItemMove
    "Creates/Updates translations for Menu Item."
    menuItemTranslate(
        "Menu Item ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): MenuItemTranslate
    "Updates a menu item."
    menuItemUpdate(
        "ID of a menu item to update."
        id: ID!,
        "Fields required to update a menu item. Only one of `url`, `category`, `page`, `collection` is allowed per item."
        input: MenuItemInput!
    ): MenuItemUpdate
    "Updates a menu."
    menuUpdate(
        "ID of a menu to update."
        id: ID!,
        "Fields required to update a menu."
        input: MenuInput!
    ): MenuUpdate
    "Adds note to the order."
    orderAddNote(
        "Fields required to create a note for the order."
        input: OrderAddNoteInput!,
        "ID of the order to add a note for."
        order: ID!
    ): OrderAddNote
    "Cancels orders."
    orderBulkCancel(
        "List of orders IDs to cancel."
        ids: [ID]!
    ): OrderBulkCancel
    "Cancel an order."
    orderCancel(
        "ID of the order to cancel."
        id: ID!
    ): OrderCancel
    "Capture an order."
    orderCapture(
        "Amount of money to capture."
        amount: PositiveDecimal!,
        "ID of the order to capture."
        id: ID!
    ): OrderCapture
    "Clears stored metadata value."
    orderClearMeta(
        "Fields required to update new or stored metadata item."
        input: MetaPath!,
        "Token of an object to clear."
        token: UUID!
    ): OrderClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Clears stored private metadata value."
    orderClearPrivateMeta(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): OrderClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Creates new fulfillments for an order."
    orderFulfill(
        "Fields required to create an fulfillment."
        input: OrderFulfillInput!,
        "ID of the order to be fulfilled."
        order: ID
    ): OrderFulfill
    "Cancels existing fulfillment and optionally restocks items."
    orderFulfillmentCancel(
        "ID of an fulfillment to cancel."
        id: ID!,
        "Fields required to cancel an fulfillment."
        input: FulfillmentCancelInput!
    ): FulfillmentCancel
    "Clears metadata for fulfillment."
    orderFulfillmentClearMeta(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): FulfillmentClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Clears private metadata for fulfillment."
    orderFulfillmentClearPrivateMeta(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): FulfillmentClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Updates metadata for fulfillment."
    orderFulfillmentUpdateMeta(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): FulfillmentUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Updates metadata for fulfillment."
    orderFulfillmentUpdatePrivateMeta(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): FulfillmentUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Updates a fulfillment for an order."
    orderFulfillmentUpdateTracking(
        "ID of an fulfillment to update."
        id: ID!,
        "Fields required to update an fulfillment."
        input: FulfillmentUpdateTrackingInput!
    ): FulfillmentUpdateTracking
    "Mark order as manually paid."
    orderMarkAsPaid(
        "ID of the order to mark paid."
        id: ID!
    ): OrderMarkAsPaid
    "Refund an order."
    orderRefund(
        "Amount of money to refund."
        amount: PositiveDecimal!,
        "ID of the order to refund."
        id: ID!
    ): OrderRefund
    "Updates an order."
    orderUpdate(
        "ID of an order to update."
        id: ID!,
        "Fields required to update an order."
        input: OrderUpdateInput!
    ): OrderUpdate
    "Updates meta for order."
    orderUpdateMeta(
        "Fields required to update new or stored metadata item."
        input: MetaInput!,
        "Token of an object to update."
        token: UUID!
    ): OrderUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Updates private meta for order."
    orderUpdatePrivateMeta(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): OrderUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Updates a shipping method of the order."
    orderUpdateShipping(
        "Fields required to change shipping method of the order."
        input: OrderUpdateShippingInput,
        "ID of the order to update a shipping method."
        order: ID!
    ): OrderUpdateShipping
    "Void an order."
    orderVoid(
        "ID of the order to void."
        id: ID!
    ): OrderVoid
    "Deletes pages."
    pageBulkDelete(
        "List of page IDs to delete."
        ids: [ID]!
    ): PageBulkDelete
    "Publish pages."
    pageBulkPublish(
        "List of page IDs to (un)publish."
        ids: [ID]!,
        "Determine if pages will be published or not."
        isPublished: Boolean!
    ): PageBulkPublish
    "Creates a new page."
    pageCreate(
        "Fields required to create a page."
        input: PageInput!
    ): PageCreate
    "Deletes a page."
    pageDelete(
        "ID of a page to delete."
        id: ID!
    ): PageDelete
    "Creates/Updates translations for Page."
    pageTranslate(
        "Page ID."
        id: ID!,
        input: PageTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): PageTranslate
    "Updates an existing page."
    pageUpdate(
        "ID of a page to update."
        id: ID!,
        "Fields required to update a page."
        input: PageInput!
    ): PageUpdate
    "Change the password of the logged in user."
    passwordChange(
        "New user password."
        newPassword: String!,
        "Current user password."
        oldPassword: String!
    ): PasswordChange
    "Captures the authorized payment amount."
    paymentCapture(
        "Transaction amount."
        amount: PositiveDecimal,
        "Payment ID."
        paymentId: ID!
    ): PaymentCapture
    "Initializes payment process when it is required by gateway."
    paymentInitialize(
        "A gateway name used to initialize the payment."
        gateway: String!,
        "Client-side generated data required to initialize the payment."
        paymentData: JSONString
    ): PaymentInitialize
    "Refunds the captured payment amount."
    paymentRefund(
        "Transaction amount."
        amount: PositiveDecimal,
        "Payment ID."
        paymentId: ID!
    ): PaymentRefund
    "Voids the authorized payment."
    paymentVoid(
        "Payment ID."
        paymentId: ID!
    ): PaymentVoid
    "Create new permission group."
    permissionGroupCreate(
        "Input fields to create permission group."
        input: PermissionGroupCreateInput!
    ): PermissionGroupCreate
    "Delete permission group."
    permissionGroupDelete(
        "ID of the group to delete."
        id: ID!
    ): PermissionGroupDelete
    "Update permission group."
    permissionGroupUpdate(
        "ID of the group to update."
        id: ID!,
        "Input fields to create permission group."
        input: PermissionGroupUpdateInput!
    ): PermissionGroupUpdate
    "Update plugin configuration."
    pluginUpdate(
        "ID of plugin to update."
        id: ID!,
        "Fields required to update a plugin configuration."
        input: PluginUpdateInput!
    ): PluginUpdate
    "Deletes products."
    productBulkDelete(
        "List of product IDs to delete."
        ids: [ID]!
    ): ProductBulkDelete
    "Publish products."
    productBulkPublish(
        "List of products IDs to publish."
        ids: [ID]!,
        "Determine if products will be published or not."
        isPublished: Boolean!
    ): ProductBulkPublish
    "Clears public metadata item for product."
    productClearMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): ProductClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Clears private metadata item for product."
    productClearPrivateMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): ProductClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Creates a new product."
    productCreate(
        "Fields required to create a product."
        input: ProductCreateInput!
    ): ProductCreate
    "Deletes a product."
    productDelete(
        "ID of a product to delete."
        id: ID!
    ): ProductDelete
    "Deletes product images."
    productImageBulkDelete(
        "List of product image IDs to delete."
        ids: [ID]!
    ): ProductImageBulkDelete
    "Create a product image. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
    productImageCreate(
        "Fields required to create a product image."
        input: ProductImageCreateInput!
    ): ProductImageCreate
    "Deletes a product image."
    productImageDelete(
        "ID of a product image to delete."
        id: ID!
    ): ProductImageDelete
    "Changes ordering of the product image."
    productImageReorder(
        "IDs of a product images in the desired order."
        imagesIds: [ID]!,
        "Id of product that images order will be altered."
        productId: ID!
    ): ProductImageReorder
    "Updates a product image."
    productImageUpdate(
        "ID of a product image to update."
        id: ID!,
        "Fields required to update a product image."
        input: ProductImageUpdateInput!
    ): ProductImageUpdate
    "Set product availability for purchase date."
    productSetAvailabilityForPurchase(
        "Determine if product should be available for purchase."
        isAvailable: Boolean!,
        "Id of product that availability for purchase should be changed."
        productId: ID!,
        "A start date from which a product will be available for purchase. When not set and isAvailable is set to True, the current day is assumed."
        startDate: Date
    ): ProductSetAvailabilityForPurchase
    "Creates/Updates translations for Product."
    productTranslate(
        "Product ID."
        id: ID!,
        input: TranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): ProductTranslate
    "Deletes product types."
    productTypeBulkDelete(
        "List of product type IDs to delete."
        ids: [ID]!
    ): ProductTypeBulkDelete
    "Clears public metadata for product type."
    productTypeClearMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): ProductTypeClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Clears private metadata for product type."
    productTypeClearPrivateMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): ProductTypeClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Creates a new product type."
    productTypeCreate(
        "Fields required to create a product type."
        input: ProductTypeInput!
    ): ProductTypeCreate
    "Deletes a product type."
    productTypeDelete(
        "ID of a product type to delete."
        id: ID!
    ): ProductTypeDelete
    "Reorder the attributes of a product type."
    productTypeReorderAttributes(
        "The list of attribute reordering operations."
        moves: [ReorderInput]!,
        "ID of a product type."
        productTypeId: ID!,
        "The attribute type to reorder."
        type: AttributeTypeEnum!
    ): ProductTypeReorderAttributes
    "Updates an existing product type."
    productTypeUpdate(
        "ID of a product type to update."
        id: ID!,
        "Fields required to update a product type."
        input: ProductTypeInput!
    ): ProductTypeUpdate
    "Update public metadata for product type."
    productTypeUpdateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): ProductTypeUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Update private metadata for product type."
    productTypeUpdatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): ProductTypeUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Updates an existing product."
    productUpdate(
        "ID of a product to update."
        id: ID!,
        "Fields required to update a product."
        input: ProductInput!
    ): ProductUpdate
    "Update public metadata for product."
    productUpdateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): ProductUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Update private metadata for product."
    productUpdatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): ProductUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Creates product variants for a given product."
    productVariantBulkCreate(
        "ID of the product to create the variants for."
        product: ID!,
        "Input list of product variants to create."
        variants: [ProductVariantBulkCreateInput]!
    ): ProductVariantBulkCreate
    "Deletes product variants."
    productVariantBulkDelete(
        "List of product variant IDs to delete."
        ids: [ID]!
    ): ProductVariantBulkDelete
    "Clears public metadata for product variant."
    productVariantClearMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): ProductVariantClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Clears private metadata for product variant."
    productVariantClearPrivateMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): ProductVariantClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Creates a new variant for a product."
    productVariantCreate(
        "Fields required to create a product variant."
        input: ProductVariantCreateInput!
    ): ProductVariantCreate
    "Deletes a product variant."
    productVariantDelete(
        "ID of a product variant to delete."
        id: ID!
    ): ProductVariantDelete
    "Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook."
    productVariantReorder(
        "The list of variant reordering operations."
        moves: [ReorderInput]!,
        "Id of product that variants order will be altered."
        productId: ID!
    ): ProductVariantReorder
    "Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook."
    productVariantSetDefault(
        "Id of a product that will have the default variant set."
        productId: ID!,
        "Id of a variant that will be set as default."
        variantId: ID!
    ): ProductVariantSetDefault
    "Creates stocks for product variant."
    productVariantStocksCreate(
        "Input list of stocks to create."
        stocks: [StockInput!]!,
        "ID of a product variant for which stocks will be created."
        variantId: ID!
    ): ProductVariantStocksCreate
    "Delete stocks from product variant."
    productVariantStocksDelete(
        "ID of product variant for which stocks will be deleted."
        variantId: ID!,
        warehouseIds: [ID!]
    ): ProductVariantStocksDelete
    "Update stocks for product variant."
    productVariantStocksUpdate(
        "Input list of stocks to create."
        stocks: [StockInput!]!,
        "ID of a product variant for which stocks will be created."
        variantId: ID!
    ): ProductVariantStocksUpdate
    "Creates/Updates translations for Product Variant."
    productVariantTranslate(
        "Product Variant ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): ProductVariantTranslate
    "Updates an existing variant for product."
    productVariantUpdate(
        "ID of a product variant to update."
        id: ID!,
        "Fields required to update a product variant."
        input: ProductVariantInput!
    ): ProductVariantUpdate
    "Update public metadata for product variant."
    productVariantUpdateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): ProductVariantUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Update private metadata for product variant."
    productVariantUpdatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): ProductVariantUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation instead. This field will be removed after 2020-07-31.")
    "Request email change of the logged in user."
    requestEmailChange(
        "New user email."
        newEmail: String!,
        "User password."
        password: String!,
        "URL of a view where users should be redirected to update the email address. URL in RFC 1808 format."
        redirectUrl: String!
    ): RequestEmailChange
    "Sends an email with the account password modification link."
    requestPasswordReset(
        "Email of the user that will be used for password recovery."
        email: String!,
        "URL of a view where users should be redirected to reset the password. URL in RFC 1808 format."
        redirectUrl: String!
    ): RequestPasswordReset
    "Deletes sales."
    saleBulkDelete(
        "List of sale IDs to delete."
        ids: [ID]!
    ): SaleBulkDelete
    "Adds products, categories, collections to a voucher."
    saleCataloguesAdd(
        "ID of a sale."
        id: ID!,
        "Fields required to modify catalogue IDs of sale."
        input: CatalogueInput!
    ): SaleAddCatalogues
    "Removes products, categories, collections from a sale."
    saleCataloguesRemove(
        "ID of a sale."
        id: ID!,
        "Fields required to modify catalogue IDs of sale."
        input: CatalogueInput!
    ): SaleRemoveCatalogues
    "Creates a new sale."
    saleCreate(
        "Fields required to create a sale."
        input: SaleInput!
    ): SaleCreate
    "Deletes a sale."
    saleDelete(
        "ID of a sale to delete."
        id: ID!
    ): SaleDelete
    "Creates/updates translations for a sale."
    saleTranslate(
        "Voucher ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): SaleTranslate
    "Updates a sale."
    saleUpdate(
        "ID of a sale to update."
        id: ID!,
        "Fields required to update a sale."
        input: SaleInput!
    ): SaleUpdate
    "Clear private metadata for a service account."
    serviceAccountClearPrivateMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): ServiceAccountClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation with App instead.This field will be removed after 2020-07-31.")
    "Creates a new service account."
    serviceAccountCreate(
        "Fields required to create a new service account."
        input: ServiceAccountInput!
    ): ServiceAccountCreate @deprecated(reason : "Use the `appCreate` mutation instead. This field will be removed after 2020-07-31.")
    "Deletes a service account."
    serviceAccountDelete(
        "ID of a service account to delete."
        id: ID!
    ): ServiceAccountDelete @deprecated(reason : "Use the `appDelete` mutation instead. This field will be removed after 2020-07-31.")
    "Creates a new token."
    serviceAccountTokenCreate(
        "Fields required to create a new auth token."
        input: ServiceAccountTokenInput!
    ): ServiceAccountTokenCreate @deprecated(reason : "Use the `appTokenCreate` mutation instead. This field will be removed after 2020-07-31.")
    "Deletes an authentication token assigned to service account."
    serviceAccountTokenDelete(
        "ID of an auth token to delete."
        id: ID!
    ): ServiceAccountTokenDelete @deprecated(reason : "Use the `appTokenDelete` mutation instead. This field will be removed after 2020-07-31.")
    "Updates an existing service account."
    serviceAccountUpdate(
        "ID of a service account to update."
        id: ID!,
        "Fields required to update an existing service account."
        input: ServiceAccountInput!
    ): ServiceAccountUpdate @deprecated(reason : "Use the `appUpdate` mutation instead. This field will be removed after 2020-07-31.")
    "Updates private metadata for a service account."
    serviceAccountUpdatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): ServiceAccountUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation with App instead.This field will be removed after 2020-07-31.")
    "Sets the user's password from the token sent by email using the RequestPasswordReset mutation."
    setPassword(
        "Email of a user."
        email: String!,
        "Password of a user."
        password: String!,
        "A one-time token required to set the password."
        token: String!
    ): SetPassword
    "Deletes shipping prices."
    shippingPriceBulkDelete(
        "List of shipping price IDs to delete."
        ids: [ID]!
    ): ShippingPriceBulkDelete
    "Creates a new shipping price."
    shippingPriceCreate(
        "Fields required to create a shipping price."
        input: ShippingPriceInput!
    ): ShippingPriceCreate
    "Deletes a shipping price."
    shippingPriceDelete(
        "ID of a shipping price to delete."
        id: ID!
    ): ShippingPriceDelete
    "Creates/Updates translations for shipping method."
    shippingPriceTranslate(
        "Shipping method ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): ShippingPriceTranslate
    "Updates a new shipping price."
    shippingPriceUpdate(
        "ID of a shipping price to update."
        id: ID!,
        "Fields required to update a shipping price."
        input: ShippingPriceInput!
    ): ShippingPriceUpdate
    "Deletes shipping zones."
    shippingZoneBulkDelete(
        "List of shipping zone IDs to delete."
        ids: [ID]!
    ): ShippingZoneBulkDelete
    "Creates a new shipping zone."
    shippingZoneCreate(
        "Fields required to create a shipping zone."
        input: ShippingZoneCreateInput!
    ): ShippingZoneCreate
    "Deletes a shipping zone."
    shippingZoneDelete(
        "ID of a shipping zone to delete."
        id: ID!
    ): ShippingZoneDelete
    "Updates a new shipping zone."
    shippingZoneUpdate(
        "ID of a shipping zone to update."
        id: ID!,
        "Fields required to update a shipping zone."
        input: ShippingZoneUpdateInput!
    ): ShippingZoneUpdate
    "Update the shop's address. If the `null` value is passed, the currently selected address will be deleted."
    shopAddressUpdate(
        "Fields required to update shop address."
        input: AddressInput
    ): ShopAddressUpdate
    "Updates site domain of the shop."
    shopDomainUpdate(
        "Fields required to update site."
        input: SiteDomainInput
    ): ShopDomainUpdate
    "Fetch tax rates."
    shopFetchTaxRates: ShopFetchTaxRates
    "Creates/Updates translations for Shop Settings."
    shopSettingsTranslate(
        "Fields required to update shop settings translations."
        input: ShopSettingsTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): ShopSettingsTranslate
    "Updates shop settings."
    shopSettingsUpdate(
        "Fields required to update shop settings."
        input: ShopSettingsInput!
    ): ShopSettingsUpdate
    "Deletes staff users."
    staffBulkDelete(
        "List of user IDs to delete."
        ids: [ID]!
    ): StaffBulkDelete
    "Creates a new staff user."
    staffCreate(
        "Fields required to create a staff user."
        input: StaffCreateInput!
    ): StaffCreate
    "Deletes a staff user."
    staffDelete(
        "ID of a staff user to delete."
        id: ID!
    ): StaffDelete
    "Creates a new staff notification recipient."
    staffNotificationRecipientCreate(
        "Fields required to create a staff notification recipient."
        input: StaffNotificationRecipientInput!
    ): StaffNotificationRecipientCreate
    "Delete staff notification recipient."
    staffNotificationRecipientDelete(
        "ID of a staff notification recipient to delete."
        id: ID!
    ): StaffNotificationRecipientDelete
    "Updates a staff notification recipient."
    staffNotificationRecipientUpdate(
        "ID of a staff notification recipient to update."
        id: ID!,
        "Fields required to update a staff notification recipient."
        input: StaffNotificationRecipientInput!
    ): StaffNotificationRecipientUpdate
    "Updates an existing staff user."
    staffUpdate(
        "ID of a staff user to update."
        id: ID!,
        "Fields required to update a staff user."
        input: StaffUpdateInput!
    ): StaffUpdate
    "Create JWT token."
    tokenCreate(
        "Email of a user."
        email: String!,
        "Password of a user."
        password: String!
    ): CreateToken
    "Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie."
    tokenRefresh(
        "CSRF token required to refresh token. This argument is required when refreshToken is provided as a cookie."
        csrfToken: String,
        "Refresh token."
        refreshToken: String
    ): RefreshToken
    "Verify JWT token."
    tokenVerify(
        "JWT token to validate."
        token: String!
    ): VerifyToken
    "Deactivate all JWT tokens of the currently authenticated user."
    tokensDeactivateAll: DeactivateAllUserTokens
    "Remove shipping zone from given warehouse."
    unassignWarehouseShippingZone(
        "ID of a warehouse to update."
        id: ID!,
        "List of shipping zone IDs."
        shippingZoneIds: [ID!]!
    ): WarehouseShippingZoneUnassign
    "Updates metadata of an object."
    updateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update the object's metadata."
        input: [MetadataInput!]!
    ): UpdateMetadata
    "Updates private metadata of an object."
    updatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update the object's metadata."
        input: [MetadataInput!]!
    ): UpdatePrivateMetadata
    "Updates given warehouse."
    updateWarehouse(
        "ID of a warehouse to update."
        id: ID!,
        "Fields required to update warehouse."
        input: WarehouseUpdateInput!
    ): WarehouseUpdate
    "Deletes a user avatar. Only for staff members."
    userAvatarDelete: UserAvatarDelete
    "Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
    userAvatarUpdate(
        "Represents an image file in a multipart request."
        image: Upload!
    ): UserAvatarUpdate
    "Activate or deactivate users."
    userBulkSetActive(
        "List of user IDs to (de)activate)."
        ids: [ID]!,
        "Determine if users will be set active or not."
        isActive: Boolean!
    ): UserBulkSetActive
    "Clear metadata for user."
    userClearMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): UserClearMeta @deprecated(reason : "Use the `deleteMetadata` mutation. This field will be removed after 2020-07-31.")
    "Clear private metadata for user."
    userClearPrivateMetadata(
        "ID of a customer to update."
        id: ID!,
        "Fields required to identify stored metadata item."
        input: MetaPath!
    ): UserClearPrivateMeta @deprecated(reason : "Use the `deletePrivateMetadata` mutation. This field will be removed after 2020-07-31.")
    "Updates metadata for user."
    userUpdateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): UserUpdateMeta @deprecated(reason : "Use the `updateMetadata` mutation. This field will be removed after 2020-07-31.")
    "Updates private metadata for user."
    userUpdatePrivateMetadata(
        "ID of an object to update."
        id: ID!,
        "Fields required to update new or stored metadata item."
        input: MetaInput!
    ): UserUpdatePrivateMeta @deprecated(reason : "Use the `updatePrivateMetadata` mutation. This field will be removed after 2020-07-31.")
    "Assign an image to a product variant."
    variantImageAssign(
        "ID of a product image to assign to a variant."
        imageId: ID!,
        "ID of a product variant."
        variantId: ID!
    ): VariantImageAssign
    "Unassign an image from a product variant."
    variantImageUnassign(
        "ID of a product image to unassign from a variant."
        imageId: ID!,
        "ID of a product variant."
        variantId: ID!
    ): VariantImageUnassign
    "Deletes vouchers."
    voucherBulkDelete(
        "List of voucher IDs to delete."
        ids: [ID]!
    ): VoucherBulkDelete
    "Adds products, categories, collections to a voucher."
    voucherCataloguesAdd(
        "ID of a voucher."
        id: ID!,
        "Fields required to modify catalogue IDs of voucher."
        input: CatalogueInput!
    ): VoucherAddCatalogues
    "Removes products, categories, collections from a voucher."
    voucherCataloguesRemove(
        "ID of a voucher."
        id: ID!,
        "Fields required to modify catalogue IDs of voucher."
        input: CatalogueInput!
    ): VoucherRemoveCatalogues
    "Creates a new voucher."
    voucherCreate(
        "Fields required to create a voucher."
        input: VoucherInput!
    ): VoucherCreate
    "Deletes a voucher."
    voucherDelete(
        "ID of a voucher to delete."
        id: ID!
    ): VoucherDelete
    "Creates/Updates translations for Voucher."
    voucherTranslate(
        "Voucher ID."
        id: ID!,
        input: NameTranslationInput!,
        "Translation language code."
        languageCode: LanguageCodeEnum!
    ): VoucherTranslate
    "Updates a voucher."
    voucherUpdate(
        "ID of a voucher to update."
        id: ID!,
        "Fields required to update a voucher."
        input: VoucherInput!
    ): VoucherUpdate
    "Creates a new webhook subscription."
    webhookCreate(
        "Fields required to create a webhook."
        input: WebhookCreateInput!
    ): WebhookCreate
    "Deletes a webhook subscription."
    webhookDelete(
        "ID of a webhook to delete."
        id: ID!
    ): WebhookDelete
    "Updates a webhook subscription."
    webhookUpdate(
        "ID of a webhook to update."
        id: ID!,
        "Fields required to update a webhook."
        input: WebhookUpdateInput!
    ): WebhookUpdate
}

"Represents shop's navigation menus."
type Navigation {
    "Main navigation bar."
    main: Menu
    "Secondary navigation bar."
    secondary: Menu
}

"Represents an order in the shop."
type Order implements Node & ObjectWithMetadata {
    "List of actions that can be performed in the current state of an order."
    actions: [OrderAction]!
    "Shipping methods that can be used with this order."
    availableShippingMethods: [ShippingMethod]
    billingAddress: Address
    "Informs whether a draft order can be finalized(turned into a regular order)."
    canFinalize: Boolean!
    created: DateTime!
    customerNote: String!
    discount: Money
    discountName: String
    displayGrossPrices: Boolean!
    "List of events associated with the order."
    events: [OrderEvent]
    "List of shipments for the order."
    fulfillments: [Fulfillment]!
    "List of user gift cards."
    giftCards: [GiftCard]
    "The ID of the object."
    id: ID!
    "List of order invoices."
    invoices: [Invoice]
    "Informs if an order is fully paid."
    isPaid: Boolean
    "Returns True, if order requires shipping."
    isShippingRequired: Boolean!
    languageCode: String!
    "List of order lines."
    lines: [OrderLine]!
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "User-friendly number of an order."
    number: String
    "Internal payment status."
    paymentStatus: PaymentChargeStatusEnum
    "User-friendly payment status."
    paymentStatusDisplay: String
    "List of payments for the order."
    payments: [Payment]
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    shippingAddress: Address
    shippingMethod: ShippingMethod
    shippingMethodName: String
    "Total price of shipping."
    shippingPrice: TaxedMoney
    status: OrderStatus!
    "User-friendly order status."
    statusDisplay: String
    "The sum of line prices not including shipping."
    subtotal: TaxedMoney
    token: String!
    "Total amount of the order."
    total: TaxedMoney
    "Amount authorized for the order."
    totalAuthorized: Money
    "The difference between the paid and the order total amount."
    totalBalance: Money!
    "Amount captured by payment."
    totalCaptured: Money
    trackingClientId: String!
    translatedDiscountName: String
    user: User
    "Email address of the customer."
    userEmail: String
    voucher: Voucher
    weight: Weight
}

"Adds note to the order."
type OrderAddNote {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Order note created."
    event: OrderEvent
    "Order with the note added."
    order: Order
    orderErrors: [OrderError!]!
}

"Cancels orders."
type OrderBulkCancel {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    orderErrors: [OrderError!]!
}

"Cancel an order."
type OrderCancel {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Canceled order."
    order: Order
    orderErrors: [OrderError!]!
}

"Capture an order."
type OrderCapture {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Captured order."
    order: Order
    orderErrors: [OrderError!]!
}

"Clears stored metadata value."
type OrderClearMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    order: Order
}

"Clears stored private metadata value."
type OrderClearPrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    order: Order
}

type OrderCountableConnection {
    edges: [OrderCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type OrderCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Order!
}

type OrderError {
    "The error code."
    code: OrderErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "Order line ID which causes the error."
    orderLine: ID
    "Warehouse ID which causes the error."
    warehouse: ID
}

"History log of the order."
type OrderEvent implements Node {
    "Amount of money."
    amount: Float
    "Composed ID of the Fulfillment."
    composedId: String
    "Date when event happened at in ISO 8601 format."
    date: DateTime
    "Email of the customer."
    email: String
    "Type of an email sent to the customer."
    emailType: OrderEventsEmailsEnum
    "The lines fulfilled."
    fulfilledItems: [FulfillmentLine]
    "The ID of the object."
    id: ID!
    "Number of an invoice related to the order."
    invoiceNumber: String
    "The concerned lines."
    lines: [OrderEventOrderLineObject]
    "Content of the event."
    message: String
    "User-friendly number of an order."
    orderNumber: String
    "List of oversold lines names."
    oversoldItems: [String]
    "The payment gateway of the payment."
    paymentGateway: String
    "The payment ID from the payment gateway."
    paymentId: String
    "Number of items."
    quantity: Int
    "Order event type."
    type: OrderEventsEnum
    "User who performed the action."
    user: User
    "The warehouse were items were restocked."
    warehouse: Warehouse
}

type OrderEventCountableConnection {
    edges: [OrderEventCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type OrderEventCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: OrderEvent!
}

type OrderEventOrderLineObject {
    "The variant name."
    itemName: String
    "The order line."
    orderLine: OrderLine
    "The variant quantity."
    quantity: Int
}

"Creates new fulfillments for an order."
type OrderFulfill {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "List of created fulfillments."
    fulfillments: [Fulfillment]
    "Fulfilled order."
    order: Order
    orderErrors: [OrderError!]!
}

"Represents order line of particular order."
type OrderLine implements Node {
    "List of allocations across warehouses."
    allocations: [Allocation!]
    digitalContentUrl: DigitalContentUrl
    "The ID of the object."
    id: ID!
    isShippingRequired: Boolean!
    productName: String!
    productSku: String!
    quantity: Int!
    quantityFulfilled: Int!
    taxRate: Float!
    "The main thumbnail for the ordered product."
    thumbnail(
        "Size of thumbnail."
        size: Int
    ): Image
    "Price of the order line."
    totalPrice: TaxedMoney
    "Product name in the customer's language"
    translatedProductName: String!
    "Variant name in the customer's language"
    translatedVariantName: String!
    "Price of the single item in the order line."
    unitPrice: TaxedMoney
    "A purchased product variant. Note: this field may be null if the variant has been removed from stock at all."
    variant: ProductVariant
    variantName: String!
}

"Mark order as manually paid."
type OrderMarkAsPaid {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Order marked as paid."
    order: Order
    orderErrors: [OrderError!]!
}

"Refund an order."
type OrderRefund {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A refunded order."
    order: Order
    orderErrors: [OrderError!]!
}

"Updates an order."
type OrderUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    order: Order
    orderErrors: [OrderError!]!
}

"Updates meta for order."
type OrderUpdateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    order: Order
}

"Updates private meta for order."
type OrderUpdatePrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    order: Order
}

"Updates a shipping method of the order."
type OrderUpdateShipping {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Order with updated shipping method."
    order: Order
    orderErrors: [OrderError!]!
}

"Void an order."
type OrderVoid {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A voided order."
    order: Order
    orderErrors: [OrderError!]!
}

"A static page that can be manually added by a shop operator through the dashboard."
type Page implements Node & ObjectWithMetadata {
    content: String!
    contentJson: JSONString!
    created: DateTime!
    "The ID of the object."
    id: ID!
    "Whether the page is published."
    isPublished: Boolean!
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    publicationDate: Date
    seoDescription: String
    seoTitle: String
    slug: String!
    title: String!
    "Returns translated page fields for the given language code."
    translation(
        "A language code to return the translation for page."
        languageCode: LanguageCodeEnum!
    ): PageTranslation
}

"Deletes pages."
type PageBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    pageErrors: [PageError!]!
}

"Publish pages."
type PageBulkPublish {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    pageErrors: [PageError!]!
}

type PageCountableConnection {
    edges: [PageCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type PageCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Page!
}

"Creates a new page."
type PageCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    page: Page
    pageErrors: [PageError!]!
}

"Deletes a page."
type PageDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    page: Page
    pageErrors: [PageError!]!
}

type PageError {
    "The error code."
    code: PageErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"The Relay compliant `PageInfo` type, containing data necessary to paginate this connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type PageTranslatableContent implements Node {
    content: String!
    contentJson: JSONString!
    "The ID of the object."
    id: ID!
    "('A static page that can be manually added by a shop operator ', 'through the dashboard.')"
    page: Page
    seoDescription: String
    seoTitle: String
    title: String!
    "Returns translated page fields for the given language code."
    translation(
        "A language code to return the translation for page."
        languageCode: LanguageCodeEnum!
    ): PageTranslation
}

"Creates/Updates translations for Page."
type PageTranslate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    page: PageTranslatableContent
    translationErrors: [TranslationError!]!
}

type PageTranslation implements Node {
    content: String!
    contentJson: JSONString!
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    seoDescription: String
    seoTitle: String
    title: String!
}

"Updates an existing page."
type PageUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    page: Page
    pageErrors: [PageError!]!
}

"Change the password of the logged in user."
type PasswordChange {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A user instance with a new password."
    user: User
}

"Represents a payment of a given type."
type Payment implements Node {
    "List of actions that can be performed in the current state of a payment."
    actions: [OrderAction]!
    "Maximum amount of money that can be captured."
    availableCaptureAmount: Money
    "Maximum amount of money that can be refunded."
    availableRefundAmount: Money
    "Total amount captured for this payment."
    capturedAmount: Money
    "Internal payment status."
    chargeStatus: PaymentChargeStatusEnum!
    checkout: Checkout
    created: DateTime!
    "The details of the card used for this payment."
    creditCard: CreditCard
    customerIpAddress: String
    gateway: String!
    "The ID of the object."
    id: ID!
    isActive: Boolean!
    modified: DateTime!
    order: Order
    token: String!
    "Total amount of the payment."
    total: Money
    "List of all transactions within this payment."
    transactions: [Transaction]
}

"Captures the authorized payment amount."
type PaymentCapture {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated payment."
    payment: Payment
    paymentErrors: [PaymentError!]!
}

type PaymentCountableConnection {
    edges: [PaymentCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type PaymentCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Payment!
}

type PaymentError {
    "The error code."
    code: PaymentErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Available payment gateway backend with configuration necessary to setup client."
type PaymentGateway {
    "Payment gateway client configuration."
    config: [GatewayConfigLine!]!
    "Payment gateway supported currencies."
    currencies: [String]!
    "Payment gateway ID."
    id: ID!
    "Payment gateway name."
    name: String!
}

"Initializes payment process when it is required by gateway."
type PaymentInitialize {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    initializedPayment: PaymentInitialized
    paymentErrors: [PaymentError!]!
}

"Server-side data generated by a payment gateway. Optional step when the payment provider requires an additional action to initialize payment session."
type PaymentInitialized {
    "Initialized data by gateway."
    data: JSONString
    "ID of a payment gateway."
    gateway: String!
    "Payment gateway name."
    name: String!
}

"Refunds the captured payment amount."
type PaymentRefund {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated payment."
    payment: Payment
    paymentErrors: [PaymentError!]!
}

"Represents a payment source stored for user in payment gateway, such as credit card."
type PaymentSource {
    "Stored credit card details if available."
    creditCardInfo: CreditCard
    "Payment gateway name."
    gateway: String!
}

"Voids the authorized payment."
type PaymentVoid {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated payment."
    payment: Payment
    paymentErrors: [PaymentError!]!
}

"Represents a permission object in a friendly form."
type Permission {
    "Internal code for permission."
    code: PermissionEnum!
    "Describe action(s) allowed to do by permission."
    name: String!
}

"Create new permission group."
type PermissionGroupCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    group: Group
    permissionGroupErrors: [PermissionGroupError!]!
}

"Delete permission group."
type PermissionGroupDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    group: Group
    permissionGroupErrors: [PermissionGroupError!]!
}

type PermissionGroupError {
    "The error code."
    code: PermissionGroupErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of permissions which causes the error."
    permissions: [PermissionEnum!]
    "List of user IDs which causes the error."
    users: [ID!]
}

"Update permission group."
type PermissionGroupUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    group: Group
    permissionGroupErrors: [PermissionGroupError!]!
}

"Plugin."
type Plugin implements Node {
    active: Boolean!
    configuration: [ConfigurationItem]
    description: String!
    id: ID!
    name: String!
}

type PluginCountableConnection {
    edges: [PluginCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type PluginCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Plugin!
}

type PluginError {
    "The error code."
    code: PluginErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Update plugin configuration."
type PluginUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    plugin: Plugin
    pluginsErrors: [PluginError!]!
}

"Represents an individual item for sale in the storefront."
type Product implements Node & ObjectWithMetadata {
    "List of attributes assigned to this product."
    attributes: [SelectedAttribute!]!
    availableForPurchase: Date
    category: Category
    chargeTaxes: Boolean!
    "List of collections for the product."
    collections: [Collection]
    defaultVariant: ProductVariant
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "Get a single product image by ID."
    imageById(
        "ID of a product image."
        id: ID
    ): ProductImage
    "List of images for the product."
    images: [ProductImage]
    "Whether the product is in stock and visible or not."
    isAvailable: Boolean
    "Whether the product is available for purchase."
    isAvailableForPurchase: Boolean
    "Whether the product is published."
    isPublished: Boolean!
    margin: Margin
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "The price of the cheapest variant (including discounts)."
    minimalVariantPrice: Money
    name: String!
    "Lists the storefront product's pricing, the current price and discounts, only meant for displaying."
    pricing: ProductPricingInfo
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    productType: ProductType!
    publicationDate: Date
    purchaseCost: MoneyRange
    seoDescription: String
    seoTitle: String
    slug: String!
    "A type of tax. Assigned by enabled tax gateway"
    taxType: TaxType
    "The main thumbnail for a product."
    thumbnail(
        "Size of thumbnail."
        size: Int
    ): Image
    "Returns translated product fields for the given language code."
    translation(
        "A language code to return the translation for product."
        languageCode: LanguageCodeEnum!
    ): ProductTranslation
    updatedAt: DateTime
    "The storefront URL for the product."
    url: String! @deprecated(reason : "This field will be removed after 2020-07-31.")
    "List of variants for the product."
    variants: [ProductVariant]
    visibleInListings: Boolean!
    weight: Weight
}

"Deletes products."
type ProductBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Publish products."
type ProductBulkPublish {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Clears public metadata item for product."
type ProductClearMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

"Clears private metadata item for product."
type ProductClearPrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

type ProductCountableConnection {
    edges: [ProductCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ProductCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Product!
}

"Creates a new product."
type ProductCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

"Deletes a product."
type ProductDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

type ProductError {
    "List of attributes IDs which causes the error."
    attributes: [ID!]
    "The error code."
    code: ProductErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Represents a product image."
type ProductImage implements Node {
    alt: String!
    "The ID of the object."
    id: ID!
    sortOrder: Int
    "The URL of the image."
    url(
        "Size of the image."
        size: Int
    ): String!
}

"Deletes product images."
type ProductImageBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Create a product image. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
type ProductImageCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    image: ProductImage
    product: Product
    productErrors: [ProductError!]!
}

"Deletes a product image."
type ProductImageDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    image: ProductImage
    product: Product
    productErrors: [ProductError!]!
}

"Changes ordering of the product image."
type ProductImageReorder {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    images: [ProductImage]
    product: Product
    productErrors: [ProductError!]!
}

"Updates a product image."
type ProductImageUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    image: ProductImage
    product: Product
    productErrors: [ProductError!]!
}

"Represents availability of a product in the storefront."
type ProductPricingInfo {
    "The discount amount if in sale (null otherwise)."
    discount: TaxedMoney
    "The discount amount in the local currency."
    discountLocalCurrency: TaxedMoney
    "Whether it is in sale or not."
    onSale: Boolean
    "The discounted price range of the product variants."
    priceRange: TaxedMoneyRange
    "The discounted price range of the product variants in the local currency."
    priceRangeLocalCurrency: TaxedMoneyRange
    "The undiscounted price range of the product variants."
    priceRangeUndiscounted: TaxedMoneyRange
}

"Set product availability for purchase date."
type ProductSetAvailabilityForPurchase {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

type ProductTranslatableContent implements Node {
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    name: String!
    "Represents an individual item for sale in the storefront."
    product: Product
    seoDescription: String
    seoTitle: String
    "Returns translated product fields for the given language code."
    translation(
        "A language code to return the translation for product."
        languageCode: LanguageCodeEnum!
    ): ProductTranslation
}

"Creates/Updates translations for Product."
type ProductTranslate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    translationErrors: [TranslationError!]!
}

type ProductTranslation implements Node {
    description: String!
    descriptionJson: JSONString!
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
    seoDescription: String
    seoTitle: String
}

"Represents a type of product. It defines what attributes are available to products of this type."
type ProductType implements Node & ObjectWithMetadata {
    availableAttributes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        filter: AttributeFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): AttributeCountableConnection
    hasVariants: Boolean!
    "The ID of the object."
    id: ID!
    isDigital: Boolean!
    isShippingRequired: Boolean!
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Product attributes of that product type."
    productAttributes: [Attribute]
    "List of products of this type."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    slug: String!
    "A type of tax rate."
    taxRate: TaxRateType
    "A type of tax. Assigned by enabled tax gateway"
    taxType: TaxType
    "Variant attributes of that product type."
    variantAttributes: [Attribute]
    weight: Weight
}

"Deletes product types."
type ProductTypeBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Clears public metadata for product type."
type ProductTypeClearMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productType: ProductType
}

"Clears private metadata for product type."
type ProductTypeClearPrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productType: ProductType
}

type ProductTypeCountableConnection {
    edges: [ProductTypeCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ProductTypeCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ProductType!
}

"Creates a new product type."
type ProductTypeCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productType: ProductType
}

"Deletes a product type."
type ProductTypeDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productType: ProductType
}

"Reorder the attributes of a product type."
type ProductTypeReorderAttributes {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    "Product type from which attributes are reordered."
    productType: ProductType
}

"Updates an existing product type."
type ProductTypeUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productType: ProductType
}

"Update public metadata for product type."
type ProductTypeUpdateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productType: ProductType
}

"Update private metadata for product type."
type ProductTypeUpdatePrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productType: ProductType
}

"Updates an existing product."
type ProductUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

"Update public metadata for product."
type ProductUpdateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

"Update private metadata for product."
type ProductUpdatePrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

"Represents a version of a product such as different size or color."
type ProductVariant implements Node & ObjectWithMetadata {
    "List of attributes assigned to this variant."
    attributes: [SelectedAttribute!]!
    "Cost price of the variant."
    costPrice: Money
    "Digital content for the product variant."
    digitalContent: DigitalContent
    "The ID of the object."
    id: ID!
    "List of images for the product variant."
    images: [ProductImage]
    "Whether the variant is in stock and visible or not."
    isAvailable: Boolean @deprecated(reason : "Use the stock field instead. This field will be removed after 2020-07-31.")
    "Gross margin percentage value."
    margin: Int
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    name: String!
    "Base price of a product variant. This field is restricted for admins. Use the pricing field to get the public price for customers."
    price: Money
    "Lists the storefront variant's pricing, the current price and discounts, only meant for displaying."
    pricing: VariantPricingInfo
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    product: Product!
    "Quantity of a product available for sale."
    quantity: Int! @deprecated(reason : "Use the stock field instead. This field will be removed after 2020-07-31.")
    "Quantity allocated for orders."
    quantityAllocated: Int @deprecated(reason : "Use the stock field instead. This field will be removed after 2020-07-31.")
    "Quantity of a product available for sale in one checkout."
    quantityAvailable(
        "Two-letter ISO 3166-1 country code. When provided, the exact quantity from a warehouse operating in shipping zones that contain this country will be returned. Otherwise, it will return the maximum quantity from all shipping zones."
        countryCode: CountryCode
    ): Int!
    "Total quantity ordered."
    quantityOrdered: Int
    "Total revenue generated by a variant in given period of time. Note: this field should be queried using `reportProductSales` query as it uses optimizations suitable for such calculations."
    revenue(period: ReportingPeriod): TaxedMoney
    sku: String!
    "Quantity of a product available for sale."
    stockQuantity: Int! @deprecated(reason : "Use the quantityAvailable field instead. This field will be removed after 2020-07-31.")
    "Stocks for the product variant."
    stocks(
        "Two-letter ISO 3166-1 country code."
        countryCode: CountryCode
    ): [Stock]
    trackInventory: Boolean!
    "Returns translated product variant fields for the given language code."
    translation(
        "A language code to return the translation for product variant."
        languageCode: LanguageCodeEnum!
    ): ProductVariantTranslation
    weight: Weight
}

"Creates product variants for a given product."
type ProductVariantBulkCreate {
    bulkProductErrors: [BulkProductError!]!
    "Returns how many objects were created."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "List of the created variants."
    productVariants: [ProductVariant!]!
}

"Deletes product variants."
type ProductVariantBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
}

"Clears public metadata for product variant."
type ProductVariantClearMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productVariant: ProductVariant
}

"Clears private metadata for product variant."
type ProductVariantClearPrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productVariant: ProductVariant
}

type ProductVariantCountableConnection {
    edges: [ProductVariantCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ProductVariantCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ProductVariant!
}

"Creates a new variant for a product."
type ProductVariantCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productVariant: ProductVariant
}

"Deletes a product variant."
type ProductVariantDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productVariant: ProductVariant
}

"Reorder the variants of a product. Mutation updates updated_at on product and triggers PRODUCT_UPDATED webhook."
type ProductVariantReorder {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

"Set default variant for a product. Mutation triggers PRODUCT_UPDATED webhook."
type ProductVariantSetDefault {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    product: Product
    productErrors: [ProductError!]!
}

"Creates stocks for product variant."
type ProductVariantStocksCreate {
    bulkStockErrors: [BulkStockError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated product variant."
    productVariant: ProductVariant
}

"Delete stocks from product variant."
type ProductVariantStocksDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated product variant."
    productVariant: ProductVariant
    stockErrors: [StockError!]!
}

"Update stocks for product variant."
type ProductVariantStocksUpdate {
    bulkStockErrors: [BulkStockError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated product variant."
    productVariant: ProductVariant
}

type ProductVariantTranslatableContent implements Node {
    "The ID of the object."
    id: ID!
    name: String!
    "Represents a version of a product such as different size or color."
    productVariant: ProductVariant
    "Returns translated product variant fields for the given language code."
    translation(
        "A language code to return the translation for product variant."
        languageCode: LanguageCodeEnum!
    ): ProductVariantTranslation
}

"Creates/Updates translations for Product Variant."
type ProductVariantTranslate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productVariant: ProductVariant
    translationErrors: [TranslationError!]!
}

type ProductVariantTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String!
}

"Updates an existing variant for product."
type ProductVariantUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productVariant: ProductVariant
}

"Update public metadata for product variant."
type ProductVariantUpdateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productVariant: ProductVariant
}

"Update private metadata for product variant."
type ProductVariantUpdatePrivateMeta {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    productErrors: [ProductError!]!
    productVariant: ProductVariant
}

type Query {
    _entities(representations: [_Any]): [_Entity]
    _service: _Service
    "Look up an address by ID."
    address(
        "ID of an address."
        id: ID!
    ): Address
    "Returns address validation rules."
    addressValidationRules(
        "City or a town name."
        city: String,
        "Sublocality like a district."
        cityArea: String,
        "Designation of a region, province or state."
        countryArea: String,
        "Two-letter ISO 3166-1 country code."
        countryCode: CountryCode!
    ): AddressValidationData
    "Look up a app by ID."
    app(
        "ID of the app."
        id: ID!
    ): App
    "List of the apps."
    apps(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for apps."
        filter: AppFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort apps."
        sortBy: AppSortingInput
    ): AppCountableConnection
    "List of all apps installations"
    appsInstallations: [AppInstallation!]!
    "Look up an attribute by ID."
    attribute(
        "ID of the attribute."
        id: ID!
    ): Attribute
    "List of the shop's attributes."
    attributes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for attributes."
        filter: AttributeFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sorting options for attributes."
        sortBy: AttributeSortingInput
    ): AttributeCountableConnection
    "List of the shop's categories."
    categories(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for categories."
        filter: CategoryFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Filter categories by the nesting level in the category tree."
        level: Int,
        "Sort categories."
        sortBy: CategorySortingInput
    ): CategoryCountableConnection
    "Look up a category by ID or slug."
    category(
        "ID of the category."
        id: ID,
        "Slug of the category"
        slug: String
    ): Category
    "Look up a checkout by token."
    checkout(
        "The checkout's token."
        token: UUID
    ): Checkout
    "Look up a checkout line by ID."
    checkoutLine(
        "ID of the checkout line."
        id: ID
    ): CheckoutLine
    "List of checkout lines."
    checkoutLines(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CheckoutLineCountableConnection
    "List of checkouts."
    checkouts(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CheckoutCountableConnection
    "Look up a collection by ID."
    collection(
        "ID of the collection."
        id: ID,
        "Slug of the category"
        slug: String
    ): Collection
    "List of the shop's collections."
    collections(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for collections."
        filter: CollectionFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort collections."
        sortBy: CollectionSortingInput
    ): CollectionCountableConnection
    "List of the shop's customers."
    customers(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for customers."
        filter: CustomerFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort customers."
        sortBy: UserSortingInput
    ): UserCountableConnection
    "Look up digital content by ID."
    digitalContent(
        "ID of the digital content."
        id: ID!
    ): DigitalContent
    "List of digital content."
    digitalContents(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): DigitalContentCountableConnection
    "List of draft orders."
    draftOrders(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "[Deprecated] Filter draft orders from a selected timespan. Use the `filter` field instead. This field will be removed after 2020-07-31."
        created: ReportingPeriod,
        "Filtering options for draft orders."
        filter: OrderDraftFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort draft orders."
        sortBy: OrderSortingInput
    ): OrderCountableConnection
    "Look up a export file by ID."
    exportFile(
        "ID of the export file job."
        id: ID!
    ): ExportFile
    "List of export files."
    exportFiles(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for export files."
        filter: ExportFileFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort export files."
        sortBy: ExportFileSortingInput
    ): ExportFileCountableConnection
    "Look up a gift card by ID."
    giftCard(
        "ID of the gift card."
        id: ID!
    ): GiftCard
    "List of gift cards."
    giftCards(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): GiftCardCountableConnection
    "List of activity events to display on homepage (at the moment it only contains order-events)."
    homepageEvents(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): OrderEventCountableConnection
    "Return the currently authenticated user."
    me: User
    "Look up a navigation menu by ID or name."
    menu(
        "ID of the menu."
        id: ID,
        "The menu's name."
        name: String,
        "The menu's slug."
        slug: String
    ): Menu
    "Look up a menu item by ID."
    menuItem(
        "ID of the menu item."
        id: ID!
    ): MenuItem
    "List of the storefronts's menu items."
    menuItems(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for menu items."
        filter: MenuItemFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort menus items."
        sortBy: MenuItemSortingInput
    ): MenuItemCountableConnection
    "List of the storefront's menus."
    menus(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for menus."
        filter: MenuFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort menus."
        sortBy: MenuSortingInput
    ): MenuCountableConnection
    "Look up an order by ID."
    order(
        "ID of an order."
        id: ID!
    ): Order
    "Look up an order by token."
    orderByToken(
        "The order's token."
        token: UUID!
    ): Order
    "List of orders."
    orders(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "[Deprecated] Filter orders from a selected timespan. Use the `filter` field instead. This field will be removed after 2020-07-31."
        created: ReportingPeriod,
        "Filtering options for orders."
        filter: OrderFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort orders."
        sortBy: OrderSortingInput,
        "[Deprecated] Filter order by status. Use the `filter` field instead. This field will be removed after 2020-07-31."
        status: OrderStatusFilter
    ): OrderCountableConnection
    "Return the total sales amount from a specific period."
    ordersTotal(
        "A period of time."
        period: ReportingPeriod
    ): TaxedMoney
    "Look up a page by ID or slug."
    page(
        "ID of the page."
        id: ID,
        "The slug of the page."
        slug: String
    ): Page
    "List of the shop's pages."
    pages(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for pages."
        filter: PageFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort pages."
        sortBy: PageSortingInput
    ): PageCountableConnection
    "Look up a payment by ID."
    payment(
        "ID of the payment."
        id: ID!
    ): Payment
    "List of payments."
    payments(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): PaymentCountableConnection
    "Look up permission group by ID."
    permissionGroup(
        "ID of the group."
        id: ID!
    ): Group
    "List of permission groups."
    permissionGroups(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for permission groups."
        filter: PermissionGroupFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort permission groups."
        sortBy: PermissionGroupSortingInput
    ): GroupCountableConnection
    "Look up a plugin by ID."
    plugin(
        "ID of the plugin."
        id: ID!
    ): Plugin
    "List of plugins."
    plugins(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for plugins."
        filter: PluginFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort plugins."
        sortBy: PluginSortingInput
    ): PluginCountableConnection
    "Look up a product by ID."
    product(
        "ID of the product."
        id: ID,
        "Slug of the category"
        slug: String
    ): Product
    "Look up a product type by ID."
    productType(
        "ID of the product type."
        id: ID!
    ): ProductType
    "List of the shop's product types."
    productTypes(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for product types."
        filter: ProductTypeFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort product types."
        sortBy: ProductTypeSortingInput
    ): ProductTypeCountableConnection
    "Look up a product variant by ID or SKU."
    productVariant(
        "ID of the product variant."
        id: ID,
        "Sku of the product variant."
        sku: String
    ): ProductVariant
    "List of product variants."
    productVariants(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for product variant."
        filter: ProductVariantFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Filter product variants by given IDs."
        ids: [ID],
        "Return the last n elements from the list."
        last: Int
    ): ProductVariantCountableConnection
    "List of the shop's products."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for products."
        filter: ProductFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort products."
        sortBy: ProductOrder,
        "[Deprecated] Filter products by stock availability. Use the `filter` field instead. This field will be removed after 2020-07-31."
        stockAvailability: StockAvailability
    ): ProductCountableConnection
    "List of top selling products."
    reportProductSales(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Span of time."
        period: ReportingPeriod!
    ): ProductVariantCountableConnection
    "Look up a sale by ID."
    sale(
        "ID of the sale."
        id: ID!
    ): Sale
    "List of the shop's sales."
    sales(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for sales."
        filter: SaleFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Search sales by name, value or type."
        query: String,
        "Sort sales."
        sortBy: SaleSortingInput
    ): SaleCountableConnection
    "Look up a service account by ID."
    serviceAccount(
        "ID of the service account."
        id: ID!
    ): ServiceAccount @deprecated(reason : "Use the `app` query instead. This field will be removed after 2020-07-31.")
    "List of the service accounts."
    serviceAccounts(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for service accounts."
        filter: ServiceAccountFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort service accounts."
        sortBy: ServiceAccountSortingInput
    ): ServiceAccountCountableConnection @deprecated(reason : "Use the `apps` query instead. This field will be removed after 2020-07-31.")
    "Look up a shipping zone by ID."
    shippingZone(
        "ID of the shipping zone."
        id: ID!
    ): ShippingZone
    "List of the shop's shipping zones."
    shippingZones(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ShippingZoneCountableConnection
    "Return information about the shop."
    shop: Shop!
    "List of the shop's staff users."
    staffUsers(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for staff users."
        filter: StaffUserInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort staff users."
        sortBy: UserSortingInput
    ): UserCountableConnection
    "Look up a stock by ID"
    stock(
        "ID of an warehouse"
        id: ID!
    ): Stock
    "List of stocks."
    stocks(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        filter: StockFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): StockCountableConnection
    "List of all tax rates available from tax gateway."
    taxTypes: [TaxType]
    translation(
        "ID of the object to retrieve."
        id: ID!,
        "Kind of the object to retrieve."
        kind: TranslatableKinds!
    ): TranslatableItem
    "Returns a list of all translatable items of a given kind."
    translations(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Kind of objects to retrieve."
        kind: TranslatableKinds!,
        "Return the last n elements from the list."
        last: Int
    ): TranslatableItemConnection
    "Look up a user by ID."
    user(
        "ID of the user."
        id: ID!
    ): User
    "Look up a voucher by ID."
    voucher(
        "ID of the voucher."
        id: ID!
    ): Voucher
    "List of the shop's vouchers."
    vouchers(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for vouchers."
        filter: VoucherFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Search vouchers by name or code."
        query: String,
        "Sort voucher."
        sortBy: VoucherSortingInput
    ): VoucherCountableConnection
    "Look up a warehouse by ID."
    warehouse(
        "ID of an warehouse"
        id: ID!
    ): Warehouse
    "List of warehouses."
    warehouses(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        filter: WarehouseFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        sortBy: WarehouseSortingInput
    ): WarehouseCountableConnection
    "Look up a webhook by ID."
    webhook(
        "ID of the webhook."
        id: ID!
    ): Webhook
    "List of all available webhook events."
    webhookEvents: [WebhookEvent]
    "Retrieve a sample payload for a given webhook event based on real data. It can be useful for some integrations where sample payload is required."
    webhookSamplePayload(
        "Name of the requested event type."
        eventType: WebhookSampleEventTypeEnum!
    ): JSONString
    "List of webhooks."
    webhooks(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Filtering options for webhooks."
        filter: WebhookFilterInput,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int,
        "Sort webhooks."
        sortBy: WebhookSortingInput
    ): WebhookCountableConnection @deprecated(reason : "Use webhooks field on app(s) query instead. This field will be removed after 2020-07-31.")
}

"Represents a reduced VAT rate for a particular type of goods."
type ReducedRate {
    "Reduced VAT rate in percent."
    rate: Float!
    "A type of goods."
    rateType: TaxRateType!
}

"Refresh JWT token. Mutation tries to take refreshToken from the input.If it fails it will try to take refreshToken from the http-only cookie -refreshToken. csrfToken is required when refreshToken is provided as a cookie."
type RefreshToken {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "JWT token, required to authenticate."
    token: String
    "A user instance."
    user: User
}

"Request email change of the logged in user."
type RequestEmailChange {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "A user instance."
    user: User
}

"Sends an email with the account password modification link."
type RequestPasswordReset {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Sales allow creating discounts for categories, collections or products and are visible to all the customers."
type Sale implements Node {
    "List of categories this sale applies to."
    categories(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    "List of collections this sale applies to."
    collections(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CollectionCountableConnection
    endDate: DateTime
    "The ID of the object."
    id: ID!
    name: String!
    "List of products this sale applies to."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    startDate: DateTime!
    "Returns translated sale fields for the given language code."
    translation(
        "A language code to return the translation for sale."
        languageCode: LanguageCodeEnum!
    ): SaleTranslation
    type: SaleType!
    value: Float!
}

"Adds products, categories, collections to a voucher."
type SaleAddCatalogues {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Sale of which catalogue IDs will be modified."
    sale: Sale
}

"Deletes sales."
type SaleBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

type SaleCountableConnection {
    edges: [SaleCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type SaleCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Sale!
}

"Creates a new sale."
type SaleCreate {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    sale: Sale
}

"Deletes a sale."
type SaleDelete {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    sale: Sale
}

"Removes products, categories, collections from a sale."
type SaleRemoveCatalogues {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Sale of which catalogue IDs will be modified."
    sale: Sale
}

type SaleTranslatableContent implements Node {
    "The ID of the object."
    id: ID!
    name: String!
    "Sales allow creating discounts for categories, collections or products and are visible to all the customers."
    sale: Sale
    "Returns translated sale fields for the given language code."
    translation(
        "A language code to return the translation for sale."
        languageCode: LanguageCodeEnum!
    ): SaleTranslation
}

"Creates/updates translations for a sale."
type SaleTranslate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    sale: Sale
    translationErrors: [TranslationError!]!
}

type SaleTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
}

"Updates a sale."
type SaleUpdate {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    sale: Sale
}

"Represents a custom attribute."
type SelectedAttribute {
    "Name of an attribute displayed in the interface."
    attribute: Attribute!
    "Values of an attribute."
    values: [AttributeValue]!
}

"Represents service account data."
type ServiceAccount implements Node & ObjectWithMetadata {
    "The date and time when the service account was created."
    created: DateTime
    "The ID of the object."
    id: ID!
    "Determine if service account will be set active or not."
    isActive: Boolean
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "Name of the service account."
    name: String
    "List of the service's permissions."
    permissions: [Permission]
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "Last 4 characters of the tokens."
    tokens: [ServiceAccountToken]
}

"Clear private metadata for a service account."
type ServiceAccountClearPrivateMeta {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    serviceAccount: ServiceAccount
}

type ServiceAccountCountableConnection {
    edges: [ServiceAccountCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ServiceAccountCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ServiceAccount!
}

"Creates a new service account."
type ServiceAccountCreate {
    accountErrors: [AccountError!]!
    "The newly created authentication token."
    authToken: String
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    serviceAccount: ServiceAccount
}

"Deletes a service account."
type ServiceAccountDelete {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    serviceAccount: ServiceAccount
}

"Represents token data."
type ServiceAccountToken implements Node {
    "Last 4 characters of the token."
    authToken: String
    "The ID of the object."
    id: ID!
    "Name of the authenticated token."
    name: String
}

"Creates a new token."
type ServiceAccountTokenCreate {
    accountErrors: [AccountError!]!
    "The newly created authentication token."
    authToken: String
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    serviceAccountToken: ServiceAccountToken
}

"Deletes an authentication token assigned to service account."
type ServiceAccountTokenDelete {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    serviceAccountToken: ServiceAccountToken
}

"Updates an existing service account."
type ServiceAccountUpdate {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    serviceAccount: ServiceAccount
}

"Updates private metadata for a service account."
type ServiceAccountUpdatePrivateMeta {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    serviceAccount: ServiceAccount
}

"Sets the user's password from the token sent by email using the RequestPasswordReset mutation."
type SetPassword {
    accountErrors: [AccountError!]!
    "CSRF token required to re-generate access token."
    csrfToken: String
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "JWT refresh token, required to re-generate access token."
    refreshToken: String
    "JWT token, required to authenticate."
    token: String
    "A user instance."
    user: User
}

type ShippingError {
    "The error code."
    code: ShippingErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
    "List of warehouse IDs which causes the error."
    warehouses: [ID!]
}

"Shipping method are the methods you'll use to get customer's orders to them. They are directly exposed to the customers."
type ShippingMethod implements Node {
    "The ID of the object."
    id: ID!
    maximumOrderPrice: Money
    maximumOrderWeight: Weight
    minimumOrderPrice: Money
    minimumOrderWeight: Weight
    name: String!
    price: Money
    "Returns translated shipping method fields for the given language code."
    translation(
        "A language code to return the translation for shipping method."
        languageCode: LanguageCodeEnum!
    ): ShippingMethodTranslation
    "Type of the shipping method."
    type: ShippingMethodTypeEnum
}

type ShippingMethodTranslatableContent implements Node {
    "The ID of the object."
    id: ID!
    name: String!
    "Shipping method are the methods you'll use to get customer's orders  to them. They are directly exposed to the customers."
    shippingMethod: ShippingMethod
    "Returns translated shipping method fields for the given language code."
    translation(
        "A language code to return the translation for shipping method."
        languageCode: LanguageCodeEnum!
    ): ShippingMethodTranslation
}

type ShippingMethodTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
}

"Deletes shipping prices."
type ShippingPriceBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shippingErrors: [ShippingError!]!
}

"Creates a new shipping price."
type ShippingPriceCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shippingErrors: [ShippingError!]!
    shippingMethod: ShippingMethod
    "A shipping zone to which the shipping method belongs."
    shippingZone: ShippingZone
}

"Deletes a shipping price."
type ShippingPriceDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shippingErrors: [ShippingError!]!
    "A shipping method to delete."
    shippingMethod: ShippingMethod
    "A shipping zone to which the shipping method belongs."
    shippingZone: ShippingZone
}

"Creates/Updates translations for shipping method."
type ShippingPriceTranslate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shippingMethod: ShippingMethod
    translationErrors: [TranslationError!]!
}

"Updates a new shipping price."
type ShippingPriceUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shippingErrors: [ShippingError!]!
    shippingMethod: ShippingMethod
    "A shipping zone to which the shipping method belongs."
    shippingZone: ShippingZone
}

"Represents a shipping zone in the shop. Zones are the concept used only for grouping shipping methods in the dashboard, and are never exposed to the customers directly."
type ShippingZone implements Node {
    "List of countries available for the method."
    countries: [CountryDisplay]
    default: Boolean!
    "The ID of the object."
    id: ID!
    name: String!
    "Lowest and highest prices for the shipping."
    priceRange: MoneyRange
    "List of shipping methods available for orders shipped to countries within this shipping zone."
    shippingMethods: [ShippingMethod]
    "List of warehouses for shipping zone."
    warehouses: [Warehouse]
}

"Deletes shipping zones."
type ShippingZoneBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shippingErrors: [ShippingError!]!
}

type ShippingZoneCountableConnection {
    edges: [ShippingZoneCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type ShippingZoneCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: ShippingZone!
}

"Creates a new shipping zone."
type ShippingZoneCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shippingErrors: [ShippingError!]!
    shippingZone: ShippingZone
}

"Deletes a shipping zone."
type ShippingZoneDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shippingErrors: [ShippingError!]!
    shippingZone: ShippingZone
}

"Updates a new shipping zone."
type ShippingZoneUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shippingErrors: [ShippingError!]!
    shippingZone: ShippingZone
}

"Represents a shop resource containing general shop data and configuration."
type Shop {
    "List of configured authorization keys. Authorization keys are used to enable third-party OAuth authorization (currently Facebook or Google)."
    authorizationKeys: [AuthorizationKey]!
    "Enable automatic fulfillment for all digital products."
    automaticFulfillmentDigitalProducts: Boolean
    "List of available payment gateways."
    availablePaymentGateways(
        "A currency for which gateways will be returned."
        currency: String
    ): [PaymentGateway!]!
    "Charge taxes on shipping."
    chargeTaxesOnShipping: Boolean!
    "Company address."
    companyAddress: Address
    "List of countries available in the shop."
    countries(
        "A language code to return the translation for."
        languageCode: LanguageCodeEnum
    ): [CountryDisplay!]!
    "List of available currencies."
    currencies: [String]! @deprecated(reason : "This field will be removed in Saleor 3.0")
    "URL of a view where customers can set their password."
    customerSetPasswordUrl: String
    "Shop's default country."
    defaultCountry: CountryDisplay
    "Shop's default currency."
    defaultCurrency: String! @deprecated(reason : "This field will be removed in Saleor 3.0")
    "Default number of max downloads per digital content URL."
    defaultDigitalMaxDownloads: Int
    "Default number of days which digital content URL will be valid."
    defaultDigitalUrlValidDays: Int
    "Default shop's email sender's address."
    defaultMailSenderAddress: String
    "Default shop's email sender's name."
    defaultMailSenderName: String
    "Default weight unit."
    defaultWeightUnit: WeightUnitsEnum
    "Shop's description."
    description: String
    "Display prices with tax in store."
    displayGrossPrices: Boolean!
    "Shop's domain data."
    domain: Domain!
    "Customer's geolocalization data."
    geolocalization: Geolocalization
    "Header text."
    headerText: String
    "Collection displayed on homepage."
    homepageCollection: Collection @deprecated(reason : "Use the `collection` query with the `slug` parameter. This field will be removed in Saleor 3.0")
    "Include taxes in prices."
    includeTaxesInPrices: Boolean!
    "List of the shops's supported languages."
    languages: [LanguageDisplay]!
    "Shop's name."
    name: String!
    "Shop's navigation."
    navigation: Navigation @deprecated(reason : "Fetch menus using the `menu` query with `slug` parameter.")
    "List of available permissions."
    permissions: [Permission]!
    "List of possible phone prefixes."
    phonePrefixes: [String]!
    "List of staff notification recipients."
    staffNotificationRecipients: [StaffNotificationRecipient]
    "Enable inventory tracking."
    trackInventoryByDefault: Boolean
    "Returns translated shop fields for the given language code."
    translation(
        "A language code to return the translation for shop."
        languageCode: LanguageCodeEnum!
    ): ShopTranslation
}

"Update the shop's address. If the `null` value is passed, the currently selected address will be deleted."
type ShopAddressUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]!
}

"Updates site domain of the shop."
type ShopDomainUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]!
}

type ShopError {
    "The error code."
    code: ShopErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Fetch tax rates."
type ShopFetchTaxRates {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]!
}

"Creates/Updates translations for Shop Settings."
type ShopSettingsTranslate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated shop."
    shop: Shop
    translationErrors: [TranslationError!]!
}

"Updates shop settings."
type ShopSettingsUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Updated shop."
    shop: Shop
    shopErrors: [ShopError!]!
}

type ShopTranslation implements Node {
    description: String!
    headerText: String!
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
}

"Deletes staff users."
type StaffBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    staffErrors: [StaffError!]!
}

"Creates a new staff user."
type StaffCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    staffErrors: [StaffError!]!
    user: User
}

"Deletes a staff user."
type StaffDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    staffErrors: [StaffError!]!
    user: User
}

type StaffError {
    "The error code."
    code: AccountErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "List of permission group IDs which cause the error."
    groups: [ID!]
    "The error message."
    message: String
    "List of permissions which causes the error."
    permissions: [PermissionEnum!]
    "List of user IDs which causes the error."
    users: [ID!]
}

"Represents a recipient of email notifications send by Saleor, such as notifications about new orders. Notifications can be assigned to staff users or arbitrary email addresses."
type StaffNotificationRecipient implements Node {
    "Determines if a notification active."
    active: Boolean
    "Returns email address of a user subscribed to email notifications."
    email: String
    "The ID of the object."
    id: ID!
    "Returns a user subscribed to email notifications."
    user: User
}

"Creates a new staff notification recipient."
type StaffNotificationRecipientCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shopErrors: [ShopError!]!
    staffNotificationRecipient: StaffNotificationRecipient
}

"Delete staff notification recipient."
type StaffNotificationRecipientDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shopErrors: [ShopError!]!
    staffNotificationRecipient: StaffNotificationRecipient
}

"Updates a staff notification recipient."
type StaffNotificationRecipientUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    shopErrors: [ShopError!]!
    staffNotificationRecipient: StaffNotificationRecipient
}

"Updates an existing staff user."
type StaffUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    staffErrors: [StaffError!]!
    user: User
}

"Represents stock."
type Stock implements Node {
    "The ID of the object."
    id: ID!
    productVariant: ProductVariant!
    "Quantity of a product in the warehouse's possession, including the allocated stock that is waiting for shipment."
    quantity: Int!
    "Quantity allocated for orders"
    quantityAllocated: Int!
    warehouse: Warehouse!
}

type StockCountableConnection {
    edges: [StockCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type StockCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Stock!
}

type StockError {
    "The error code."
    code: StockErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Representation of tax types fetched from tax gateway."
type TaxType {
    "Description of the tax type."
    description: String
    "External tax code used to identify given tax group."
    taxCode: String
}

"Represents a monetary value with taxes. In cases where taxes were not applied, net and gross values will be equal."
type TaxedMoney {
    "Currency code."
    currency: String!
    "Amount of money including taxes."
    gross: Money!
    "Amount of money without taxes."
    net: Money!
    "Amount of taxes."
    tax: Money!
}

"Represents a range of monetary values."
type TaxedMoneyRange {
    "Lower bound of a price range."
    start: TaxedMoney
    "Upper bound of a price range."
    stop: TaxedMoney
}

"An object representing a single payment."
type Transaction implements Node {
    "Total amount of the transaction."
    amount: Money
    created: DateTime!
    error: TransactionError
    "The ID of the object."
    id: ID!
    isSuccess: Boolean!
    kind: TransactionKind!
    payment: Payment!
    token: String!
}

type TranslatableItemConnection {
    edges: [TranslatableItemEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type TranslatableItemEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: TranslatableItem!
}

type TranslationError {
    "The error code."
    code: TranslationErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Updates metadata of an object."
type UpdateMetadata {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    item: ObjectWithMetadata
    metadataErrors: [MetadataError!]!
}

"Updates private metadata of an object."
type UpdatePrivateMetadata {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    item: ObjectWithMetadata
    metadataErrors: [MetadataError!]!
}

"Represents user data."
type User implements Node & ObjectWithMetadata {
    "List of all user's addresses."
    addresses: [Address]
    avatar(
        "Size of the avatar."
        size: Int
    ): Image
    "Returns the last open checkout of this user."
    checkout: Checkout
    dateJoined: DateTime!
    defaultBillingAddress: Address
    defaultShippingAddress: Address
    "List of user's permission groups which user can manage."
    editableGroups: [Group]
    email: String!
    "List of events associated with the user."
    events: [CustomerEvent]
    firstName: String!
    "List of the user gift cards."
    giftCards(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): GiftCardCountableConnection
    "The ID of the object."
    id: ID!
    isActive: Boolean!
    isStaff: Boolean!
    lastLogin: DateTime
    lastName: String!
    "List of publicly stored metadata namespaces."
    meta: [MetaStore]! @deprecated(reason : "Use the `metadata` field. This field will be removed after 2020-07-31.")
    "List of public metadata items. Can be accessed without permissions."
    metadata: [MetadataItem]!
    "A note about the customer."
    note: String
    "List of user's orders."
    orders(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): OrderCountableConnection
    "List of user's permission groups."
    permissionGroups: [Group]
    "List of user's permissions."
    permissions: [Permission] @deprecated(reason : "Will be removed in Saleor 2.11.Use the `userPermissions` instead.")
    "List of privately stored metadata namespaces."
    privateMeta: [MetaStore]! @deprecated(reason : "Use the `privetaMetadata` field. This field will be removed after 2020-07-31.")
    "List of private metadata items.Requires proper staff permissions to access."
    privateMetadata: [MetadataItem]!
    "List of stored payment sources."
    storedPaymentSources: [PaymentSource]
    "List of user's permissions."
    userPermissions: [UserPermission]
}

"Deletes a user avatar. Only for staff members."
type UserAvatarDelete {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "An updated user instance."
    user: User
}

"Create a user avatar. Only for staff members. This mutation must be sent as a `multipart` request. More detailed specs of the upload format can be found here: https://github.com/jaydenseric/graphql-multipart-request-spec"
type UserAvatarUpdate {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "An updated user instance."
    user: User
}

"Activate or deactivate users."
type UserBulkSetActive {
    accountErrors: [AccountError!]!
    "Returns how many objects were affected."
    count: Int!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

"Clear metadata for user."
type UserClearMeta {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

"Clear private metadata for user."
type UserClearPrivateMeta {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

type UserCountableConnection {
    edges: [UserCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type UserCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: User!
}

type UserPermission {
    "Internal code for permission."
    code: PermissionEnum!
    "Describe action(s) allowed to do by permission."
    name: String!
    "List of user permission groups which contains this permission."
    sourcePermissionGroups(
        "ID of user whose groups should be returned."
        userId: ID!
    ): [Group!]
}

"Updates metadata for user."
type UserUpdateMeta {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

"Updates private metadata for user."
type UserUpdatePrivateMeta {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    user: User
}

"Represents a VAT rate for a country."
type VAT {
    "Country code."
    countryCode: String!
    "Country's VAT rate exceptions for specific types of goods."
    reducedRates: [ReducedRate]!
    "Standard VAT rate in percent."
    standardRate: Float
}

"Assign an image to a product variant."
type VariantImageAssign {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    image: ProductImage
    productErrors: [ProductError!]!
    productVariant: ProductVariant
}

"Unassign an image from a product variant."
type VariantImageUnassign {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    image: ProductImage
    productErrors: [ProductError!]!
    productVariant: ProductVariant
}

"Represents availability of a variant in the storefront."
type VariantPricingInfo {
    "The discount amount if in sale (null otherwise)."
    discount: TaxedMoney
    "The discount amount in the local currency."
    discountLocalCurrency: TaxedMoney
    "Whether it is in sale or not."
    onSale: Boolean
    "The price, with any discount subtracted."
    price: TaxedMoney
    "The discounted price in the local currency."
    priceLocalCurrency: TaxedMoney
    "The price without any discount."
    priceUndiscounted: TaxedMoney
}

"Verify JWT token."
type VerifyToken {
    accountErrors: [AccountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Determine if token is valid or not."
    isValid: Boolean!
    "JWT payload."
    payload: GenericScalar
    "User assigned to token."
    user: User
}

"Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes."
type Voucher implements Node {
    applyOncePerCustomer: Boolean!
    applyOncePerOrder: Boolean!
    "List of categories this voucher applies to."
    categories(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CategoryCountableConnection
    code: String!
    "List of collections this voucher applies to."
    collections(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): CollectionCountableConnection
    "List of countries available for the shipping voucher."
    countries: [CountryDisplay]
    discountValue: Float!
    "Determines a type of discount for voucher - value or percentage"
    discountValueType: DiscountValueTypeEnum!
    endDate: DateTime
    "The ID of the object."
    id: ID!
    minCheckoutItemsQuantity: Int
    minSpent: Money
    name: String
    "List of products this voucher applies to."
    products(
        "Return the elements in the list that come after the specified cursor."
        after: String,
        "Return the elements in the list that come before the specified cursor."
        before: String,
        "Return the first n elements from the list."
        first: Int,
        "Return the last n elements from the list."
        last: Int
    ): ProductCountableConnection
    startDate: DateTime!
    "Returns translated voucher fields for the given language code."
    translation(
        "A language code to return the translation for voucher."
        languageCode: LanguageCodeEnum!
    ): VoucherTranslation
    "Determines a type of voucher."
    type: VoucherTypeEnum!
    usageLimit: Int
    used: Int!
}

"Adds products, categories, collections to a voucher."
type VoucherAddCatalogues {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Voucher of which catalogue IDs will be modified."
    voucher: Voucher
}

"Deletes vouchers."
type VoucherBulkDelete {
    "Returns how many objects were affected."
    count: Int!
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
}

type VoucherCountableConnection {
    edges: [VoucherCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type VoucherCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Voucher!
}

"Creates a new voucher."
type VoucherCreate {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    voucher: Voucher
}

"Deletes a voucher."
type VoucherDelete {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    voucher: Voucher
}

"Removes products, categories, collections from a voucher."
type VoucherRemoveCatalogues {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    "Voucher of which catalogue IDs will be modified."
    voucher: Voucher
}

type VoucherTranslatableContent implements Node {
    "The ID of the object."
    id: ID!
    name: String
    "Returns translated voucher fields for the given language code."
    translation(
        "A language code to return the translation for voucher."
        languageCode: LanguageCodeEnum!
    ): VoucherTranslation
    "Vouchers allow giving discounts to particular customers on categories, collections or specific products. They can be used during checkout by providing valid voucher codes."
    voucher: Voucher
}

"Creates/Updates translations for Voucher."
type VoucherTranslate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    translationErrors: [TranslationError!]!
    voucher: Voucher
}

type VoucherTranslation implements Node {
    "The ID of the object."
    id: ID!
    "Translation language."
    language: LanguageDisplay!
    name: String
}

"Updates a voucher."
type VoucherUpdate {
    discountErrors: [DiscountError!]!
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    voucher: Voucher
}

"Represents warehouse."
type Warehouse implements Node {
    address: Address!
    companyName: String!
    email: String!
    "The ID of the object."
    id: ID!
    name: String!
    shippingZones(after: String, before: String, first: Int, last: Int): ShippingZoneCountableConnection!
    slug: String!
}

type WarehouseCountableConnection {
    edges: [WarehouseCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type WarehouseCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Warehouse!
}

"Creates new warehouse."
type WarehouseCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]!
}

"Deletes selected warehouse."
type WarehouseDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]!
}

type WarehouseError {
    "The error code."
    code: WarehouseErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Add shipping zone to given warehouse."
type WarehouseShippingZoneAssign {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]!
}

"Remove shipping zone from given warehouse."
type WarehouseShippingZoneUnassign {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]!
}

"Updates given warehouse."
type WarehouseUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    warehouse: Warehouse
    warehouseErrors: [WarehouseError!]!
}

"Webhook."
type Webhook implements Node {
    app: App!
    "List of webhook events."
    events: [WebhookEvent!]!
    "The ID of the object."
    id: ID!
    isActive: Boolean!
    name: String!
    secretKey: String
    serviceAccount: ServiceAccount! @deprecated(reason : "Use the `app` field instead. This field will be removed after 2020-07-31.")
    targetUrl: String!
}

type WebhookCountableConnection {
    edges: [WebhookCountableEdge!]!
    "Pagination data for this connection."
    pageInfo: PageInfo!
    "A total count of items in the collection."
    totalCount: Int
}

type WebhookCountableEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Webhook!
}

"Creates a new webhook subscription."
type WebhookCreate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    webhook: Webhook
    webhookErrors: [WebhookError!]!
}

"Deletes a webhook subscription."
type WebhookDelete {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    webhook: Webhook
    webhookErrors: [WebhookError!]!
}

type WebhookError {
    "The error code."
    code: WebhookErrorCode!
    "Name of a field that caused the error. A value of `null` indicates that the error isn't associated with a particular field."
    field: String
    "The error message."
    message: String
}

"Webhook event."
type WebhookEvent {
    "Internal name of the event type."
    eventType: WebhookEventTypeEnum!
    "Display name of the event."
    name: String!
}

"Updates a webhook subscription."
type WebhookUpdate {
    "List of errors that occurred executing the mutation."
    errors: [Error!]! @deprecated(reason : "Use typed errors with error codes. This field will be removed after 2020-07-31.")
    webhook: Webhook
    webhookErrors: [WebhookError!]!
}

"Represents weight value in a specific weight unit."
type Weight {
    "Weight unit."
    unit: WeightUnitsEnum!
    "Weight value."
    value: Float!
}

type _Service {
    sdl: String
}

"An enumeration."
enum AccountErrorCode {
    ACTIVATE_OWN_ACCOUNT
    ACTIVATE_SUPERUSER_ACCOUNT
    DEACTIVATE_OWN_ACCOUNT
    DEACTIVATE_SUPERUSER_ACCOUNT
    DELETE_NON_STAFF_USER
    DELETE_OWN_ACCOUNT
    DELETE_STAFF_ACCOUNT
    DELETE_SUPERUSER_ACCOUNT
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INVALID
    INVALID_CREDENTIALS
    INVALID_PASSWORD
    JWT_DECODE_ERROR
    JWT_INVALID_CSRF_TOKEN
    JWT_INVALID_TOKEN
    JWT_MISSING_TOKEN
    JWT_SIGNATURE_EXPIRED
    LEFT_NOT_MANAGEABLE_PERMISSION
    NOT_FOUND
    OUT_OF_SCOPE_GROUP
    OUT_OF_SCOPE_PERMISSION
    OUT_OF_SCOPE_SERVICE_ACCOUNT
    OUT_OF_SCOPE_USER
    PASSWORD_ENTIRELY_NUMERIC
    PASSWORD_TOO_COMMON
    PASSWORD_TOO_SHORT
    PASSWORD_TOO_SIMILAR
    REQUIRED
    UNIQUE
}

"An enumeration."
enum AddressTypeEnum {
    BILLING
    SHIPPING
}

"An enumeration."
enum AppErrorCode {
    FORBIDDEN
    GRAPHQL_ERROR
    INVALID
    INVALID_MANIFEST_FORMAT
    INVALID_PERMISSION
    INVALID_STATUS
    INVALID_URL_FORMAT
    MANIFEST_URL_CANT_CONNECT
    NOT_FOUND
    OUT_OF_SCOPE_APP
    OUT_OF_SCOPE_PERMISSION
    REQUIRED
    UNIQUE
}

enum AppSortField {
    "Sort apps by creation date."
    CREATION_DATE
    "Sort apps by name."
    NAME
}

"An enumeration."
enum AppTypeEnum {
    LOCAL
    THIRDPARTY
}

"An enumeration."
enum AttributeInputTypeEnum {
    DROPDOWN
    MULTISELECT
}

enum AttributeSortField {
    "Sort attributes based on whether they can be displayed or not in a product grid."
    AVAILABLE_IN_GRID
    "Sort attributes by the filterable in dashboard flag"
    FILTERABLE_IN_DASHBOARD
    "Sort attributes by the filterable in storefront flag"
    FILTERABLE_IN_STOREFRONT
    "Sort attributes by the variant only flag"
    IS_VARIANT_ONLY
    "Sort attributes by name"
    NAME
    "Sort attributes by slug"
    SLUG
    "Sort attributes by their position in storefront"
    STOREFRONT_SEARCH_POSITION
    "Sort attributes by the value required flag"
    VALUE_REQUIRED
    "Sort attributes by visibility in the storefront"
    VISIBLE_IN_STOREFRONT
}

enum AttributeTypeEnum {
    PRODUCT
    VARIANT
}

enum AttributeValueType {
    COLOR
    GRADIENT
    STRING
    URL
}

"An enumeration."
enum AuthorizationKeyType {
    FACEBOOK
    GOOGLE_OAUTH2
}

enum CategorySortField {
    "Sort categories by name."
    NAME
    "Sort categories by product count."
    PRODUCT_COUNT
    "Sort categories by subcategory count."
    SUBCATEGORY_COUNT
}

"An enumeration."
enum CheckoutErrorCode {
    BILLING_ADDRESS_NOT_SET
    CHECKOUT_NOT_FULLY_PAID
    GRAPHQL_ERROR
    INSUFFICIENT_STOCK
    INVALID
    INVALID_SHIPPING_METHOD
    NOT_FOUND
    PAYMENT_ERROR
    PRODUCT_NOT_PUBLISHED
    PRODUCT_UNAVAILABLE_FOR_PURCHASE
    QUANTITY_GREATER_THAN_LIMIT
    REQUIRED
    SHIPPING_ADDRESS_NOT_SET
    SHIPPING_METHOD_NOT_APPLICABLE
    SHIPPING_METHOD_NOT_SET
    SHIPPING_NOT_REQUIRED
    TAX_ERROR
    UNIQUE
    VOUCHER_NOT_APPLICABLE
    ZERO_QUANTITY
}

enum CollectionPublished {
    HIDDEN
    PUBLISHED
}

enum CollectionSortField {
    "Sort collections by availability."
    AVAILABILITY
    "Sort collections by name."
    NAME
    "Sort collections by product count."
    PRODUCT_COUNT
    "Sort collections by publication date."
    PUBLICATION_DATE
}

"An enumeration."
enum ConfigurationTypeFieldEnum {
    BOOLEAN
    PASSWORD
    SECRET
    SECRETMULTILINE
    STRING
}

"An enumeration."
enum CountryCode {
    AD
    AE
    AF
    AG
    AI
    AL
    AM
    AO
    AQ
    AR
    AS
    AT
    AU
    AW
    AX
    AZ
    BA
    BB
    BD
    BE
    BF
    BG
    BH
    BI
    BJ
    BL
    BM
    BN
    BO
    BQ
    BR
    BS
    BT
    BV
    BW
    BY
    BZ
    CA
    CC
    CD
    CF
    CG
    CH
    CI
    CK
    CL
    CM
    CN
    CO
    CR
    CU
    CV
    CW
    CX
    CY
    CZ
    DE
    DJ
    DK
    DM
    DO
    DZ
    EC
    EE
    EG
    EH
    ER
    ES
    ET
    EU
    FI
    FJ
    FK
    FM
    FO
    FR
    GA
    GB
    GD
    GE
    GF
    GG
    GH
    GI
    GL
    GM
    GN
    GP
    GQ
    GR
    GS
    GT
    GU
    GW
    GY
    HK
    HM
    HN
    HR
    HT
    HU
    ID
    IE
    IL
    IM
    IN
    IO
    IQ
    IR
    IS
    IT
    JE
    JM
    JO
    JP
    KE
    KG
    KH
    KI
    KM
    KN
    KP
    KR
    KW
    KY
    KZ
    LA
    LB
    LC
    LI
    LK
    LR
    LS
    LT
    LU
    LV
    LY
    MA
    MC
    MD
    ME
    MF
    MG
    MH
    MK
    ML
    MM
    MN
    MO
    MP
    MQ
    MR
    MS
    MT
    MU
    MV
    MW
    MX
    MY
    MZ
    NA
    NC
    NE
    NF
    NG
    NI
    NL
    NO
    NP
    NR
    NU
    NZ
    OM
    PA
    PE
    PF
    PG
    PH
    PK
    PL
    PM
    PN
    PR
    PS
    PT
    PW
    PY
    QA
    RE
    RO
    RS
    RU
    RW
    SA
    SB
    SC
    SD
    SE
    SG
    SH
    SI
    SJ
    SK
    SL
    SM
    SN
    SO
    SR
    SS
    ST
    SV
    SX
    SY
    SZ
    TC
    TD
    TF
    TG
    TH
    TJ
    TK
    TL
    TM
    TN
    TO
    TR
    TT
    TV
    TW
    TZ
    UA
    UG
    UM
    US
    UY
    UZ
    VA
    VC
    VE
    VG
    VI
    VN
    VU
    WF
    WS
    YE
    YT
    ZA
    ZM
    ZW
}

"An enumeration."
enum CustomerEventsEnum {
    ACCOUNT_CREATED
    CUSTOMER_DELETED
    DIGITAL_LINK_DOWNLOADED
    EMAIL_ASSIGNED
    EMAIL_CHANGED
    EMAIL_CHANGED_REQUEST
    NAME_ASSIGNED
    NOTE_ADDED
    NOTE_ADDED_TO_ORDER
    PASSWORD_CHANGED
    PASSWORD_RESET
    PASSWORD_RESET_LINK_SENT
    PLACED_ORDER
}

"An enumeration."
enum DiscountErrorCode {
    ALREADY_EXISTS
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

enum DiscountStatusEnum {
    ACTIVE
    EXPIRED
    SCHEDULED
}

enum DiscountValueTypeEnum {
    FIXED
    PERCENTAGE
}

"An enumeration."
enum ExportErrorCode {
    INVALID
    NOT_FOUND
    REQUIRED
}

"An enumeration."
enum ExportEventsEnum {
    EXPORTED_FILE_SENT
    EXPORT_DELETED
    EXPORT_FAILED
    EXPORT_FAILED_INFO_SENT
    EXPORT_PENDING
    EXPORT_SUCCESS
}

enum ExportFileSortField {
    "Sort export file by created at."
    CREATED_AT
    "Sort export file by status."
    STATUS
    "Sort export file by updated at."
    UPDATED_AT
}

enum ExportScope {
    "Export all products."
    ALL
    "Export the filtered products."
    FILTER
    "Export products with given ids."
    IDS
}

"An enumeration."
enum FileTypesEnum {
    CSV
    XLSX
}

"An enumeration."
enum FulfillmentStatus {
    "Canceled"
    CANCELED
    "Fulfilled"
    FULFILLED
}

"An enumeration."
enum GiftCardErrorCode {
    ALREADY_EXISTS
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"An enumeration."
enum InvoiceErrorCode {
    EMAIL_NOT_SET
    INVALID_STATUS
    NOT_FOUND
    NOT_READY
    NUMBER_NOT_SET
    REQUIRED
    URL_NOT_SET
}

"An enumeration."
enum JobStatusEnum {
    DELETED
    FAILED
    PENDING
    SUCCESS
}

"An enumeration."
enum LanguageCodeEnum {
    AR
    AZ
    BG
    BN
    CA
    CS
    DA
    DE
    EL
    EN
    ES
    ES_CO
    ET
    FA
    FI
    FR
    HI
    HU
    HY
    ID
    IS
    IT
    JA
    KA
    KM
    KO
    LT
    MN
    MY
    NB
    NL
    PL
    PT
    PT_BR
    RO
    RU
    SK
    SL
    SQ
    SR
    SV
    SW
    TA
    TH
    TR
    UK
    VI
    ZH_HANS
    ZH_HANT
}

"An enumeration."
enum MenuErrorCode {
    CANNOT_ASSIGN_NODE
    GRAPHQL_ERROR
    INVALID
    INVALID_MENU_ITEM
    NOT_FOUND
    NO_MENU_ITEM_PROVIDED
    REQUIRED
    TOO_MANY_MENU_ITEMS
    UNIQUE
}

enum MenuItemsSortField {
    "Sort menu items by name."
    NAME
}

enum MenuSortField {
    "Sort menus by items count."
    ITEMS_COUNT
    "Sort menus by name."
    NAME
}

"An enumeration."
enum MetadataErrorCode {
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
}

enum NavigationType {
    "Main storefront navigation."
    MAIN
    "Secondary storefront navigation."
    SECONDARY
}

enum OrderAction {
    "Represents the capture action."
    CAPTURE
    "Represents a mark-as-paid action."
    MARK_AS_PAID
    "Represents a refund action."
    REFUND
    "Represents a void action."
    VOID
}

enum OrderDirection {
    "Specifies an ascending sort order."
    ASC
    "Specifies a descending sort order."
    DESC
}

"An enumeration."
enum OrderErrorCode {
    BILLING_ADDRESS_NOT_SET
    CANNOT_CANCEL_FULFILLMENT
    CANNOT_CANCEL_ORDER
    CANNOT_DELETE
    CANNOT_REFUND
    CAPTURE_INACTIVE_PAYMENT
    DUPLICATED_INPUT_ITEM
    FULFILL_ORDER_LINE
    GRAPHQL_ERROR
    INSUFFICIENT_STOCK
    INVALID
    NOT_EDITABLE
    NOT_FOUND
    ORDER_NO_SHIPPING_ADDRESS
    PAYMENT_ERROR
    PAYMENT_MISSING
    PRODUCT_NOT_PUBLISHED
    PRODUCT_UNAVAILABLE_FOR_PURCHASE
    REQUIRED
    SHIPPING_METHOD_NOT_APPLICABLE
    SHIPPING_METHOD_REQUIRED
    TAX_ERROR
    UNIQUE
    VOID_INACTIVE_PAYMENT
    ZERO_QUANTITY
}

"An enumeration."
enum OrderEventsEmailsEnum {
    DIGITAL_LINKS
    FULFILLMENT_CONFIRMATION
    ORDER_CANCEL
    ORDER_CONFIRMATION
    ORDER_REFUND
    PAYMENT_CONFIRMATION
    SHIPPING_CONFIRMATION
    TRACKING_UPDATED
}

"An enumeration."
enum OrderEventsEnum {
    CANCELED
    DRAFT_ADDED_PRODUCTS
    DRAFT_CREATED
    DRAFT_REMOVED_PRODUCTS
    EMAIL_SENT
    EXTERNAL_SERVICE_NOTIFICATION
    FULFILLMENT_CANCELED
    FULFILLMENT_FULFILLED_ITEMS
    FULFILLMENT_RESTOCKED_ITEMS
    INVOICE_GENERATED
    INVOICE_REQUESTED
    INVOICE_SENT
    INVOICE_UPDATED
    NOTE_ADDED
    ORDER_FULLY_PAID
    ORDER_MARKED_AS_PAID
    OTHER
    OVERSOLD_ITEMS
    PAYMENT_AUTHORIZED
    PAYMENT_CAPTURED
    PAYMENT_FAILED
    PAYMENT_REFUNDED
    PAYMENT_VOIDED
    PLACED
    PLACED_FROM_DRAFT
    TRACKING_UPDATED
    UPDATED_ADDRESS
}

enum OrderSortField {
    "Sort orders by creation date."
    CREATION_DATE
    "Sort orders by customer."
    CUSTOMER
    "Sort orders by fulfillment status."
    FULFILLMENT_STATUS
    "Sort orders by number."
    NUMBER
    "Sort orders by payment."
    PAYMENT
    "Sort orders by total."
    TOTAL
}

"An enumeration."
enum OrderStatus {
    "Canceled"
    CANCELED
    "Draft"
    DRAFT
    "Fulfilled"
    FULFILLED
    "Partially fulfilled"
    PARTIALLY_FULFILLED
    "Unfulfilled"
    UNFULFILLED
}

enum OrderStatusFilter {
    CANCELED
    FULFILLED
    PARTIALLY_FULFILLED
    READY_TO_CAPTURE
    READY_TO_FULFILL
    UNFULFILLED
}

"An enumeration."
enum PageErrorCode {
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

enum PageSortField {
    "Sort pages by creation date."
    CREATION_DATE
    "Sort pages by publication date."
    PUBLICATION_DATE
    "Sort pages by slug."
    SLUG
    "Sort pages by title."
    TITLE
    "Sort pages by visibility."
    VISIBILITY
}

"An enumeration."
enum PaymentChargeStatusEnum {
    CANCELLED
    FULLY_CHARGED
    FULLY_REFUNDED
    NOT_CHARGED
    PARTIALLY_CHARGED
    PARTIALLY_REFUNDED
    PENDING
    REFUSED
}

"An enumeration."
enum PaymentErrorCode {
    BILLING_ADDRESS_NOT_SET
    GRAPHQL_ERROR
    INVALID
    INVALID_SHIPPING_METHOD
    NOT_FOUND
    NOT_SUPPORTED_GATEWAY
    PARTIAL_PAYMENT_NOT_ALLOWED
    PAYMENT_ERROR
    REQUIRED
    SHIPPING_ADDRESS_NOT_SET
    SHIPPING_METHOD_NOT_SET
    UNIQUE
}

"An enumeration."
enum PermissionEnum {
    MANAGE_APPS
    MANAGE_CHECKOUTS
    MANAGE_DISCOUNTS
    MANAGE_GIFT_CARD
    MANAGE_MENUS
    MANAGE_ORDERS
    MANAGE_PAGES
    MANAGE_PLUGINS
    MANAGE_PRODUCTS
    MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES
    MANAGE_SERVICE_ACCOUNTS
    MANAGE_SETTINGS
    MANAGE_SHIPPING
    MANAGE_STAFF
    MANAGE_TRANSLATIONS
    MANAGE_USERS
}

"An enumeration."
enum PermissionGroupErrorCode {
    ASSIGN_NON_STAFF_MEMBER
    CANNOT_REMOVE_FROM_LAST_GROUP
    DUPLICATED_INPUT_ITEM
    LEFT_NOT_MANAGEABLE_PERMISSION
    OUT_OF_SCOPE_PERMISSION
    OUT_OF_SCOPE_USER
    REQUIRED
    UNIQUE
}

enum PermissionGroupSortField {
    "Sort permission group accounts by name."
    NAME
}

"An enumeration."
enum PluginErrorCode {
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    PLUGIN_MISCONFIGURED
    REQUIRED
    UNIQUE
}

enum PluginSortField {
    IS_ACTIVE
    NAME
}

"An enumeration."
enum ProductErrorCode {
    ALREADY_EXISTS
    ATTRIBUTE_ALREADY_ASSIGNED
    ATTRIBUTE_CANNOT_BE_ASSIGNED
    ATTRIBUTE_VARIANTS_DISABLED
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    NOT_PRODUCTS_IMAGE
    NOT_PRODUCTS_VARIANT
    REQUIRED
    UNIQUE
    VARIANT_NO_DIGITAL_CONTENT
}

enum ProductFieldEnum {
    AVAILABLE_FOR_PURCHASE
    CATEGORY
    CHARGE_TAXES
    COLLECTIONS
    COST_PRICE
    DESCRIPTION
    NAME
    PRODUCT_IMAGES
    PRODUCT_TYPE
    PRODUCT_WEIGHT
    SEARCHABLE
    VARIANT_IMAGES
    VARIANT_PRICE
    VARIANT_SKU
    VARIANT_WEIGHT
    VISIBLE
}

enum ProductOrderField {
    "Sort products by collection. Note: This option is available only for the `Collection.products` query."
    COLLECTION
    "Sort products by update date."
    DATE
    "Sort products by a minimal price of a product's variant."
    MINIMAL_PRICE
    "Sort products by name."
    NAME
    "Sort products by price."
    PRICE
    "Sort products by publication date."
    PUBLICATION_DATE
    "Sort products by publication status."
    PUBLISHED
    "Sort products by type."
    TYPE
}

enum ProductTypeConfigurable {
    CONFIGURABLE
    SIMPLE
}

enum ProductTypeEnum {
    DIGITAL
    SHIPPABLE
}

enum ProductTypeSortField {
    "Sort products by type."
    DIGITAL
    "Sort products by name."
    NAME
    "Sort products by shipping."
    SHIPPING_REQUIRED
}

enum ReportingPeriod {
    THIS_MONTH
    TODAY
}

enum SaleSortField {
    "Sort sales by end date."
    END_DATE
    "Sort sales by name."
    NAME
    "Sort sales by start date."
    START_DATE
    "Sort sales by type."
    TYPE
    "Sort sales by value."
    VALUE
}

"An enumeration."
enum SaleType {
    "USD"
    FIXED
    "%"
    PERCENTAGE
}

enum ServiceAccountSortField {
    "Sort service accounts by creation date."
    CREATION_DATE
    "Sort service accounts by name."
    NAME
}

"An enumeration."
enum ShippingErrorCode {
    ALREADY_EXISTS
    DUPLICATED_INPUT_ITEM
    GRAPHQL_ERROR
    INVALID
    MAX_LESS_THAN_MIN
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"An enumeration."
enum ShippingMethodTypeEnum {
    PRICE
    WEIGHT
}

"An enumeration."
enum ShopErrorCode {
    ALREADY_EXISTS
    CANNOT_FETCH_TAX_RATES
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

enum StaffMemberStatus {
    ACTIVE
    DEACTIVATED
}

enum StockAvailability {
    IN_STOCK
    OUT_OF_STOCK
}

"An enumeration."
enum StockErrorCode {
    ALREADY_EXISTS
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"An enumeration."
enum TaxRateType {
    ACCOMMODATION
    ADMISSION_TO_CULTURAL_EVENTS
    ADMISSION_TO_ENTERTAINMENT_EVENTS
    ADMISSION_TO_SPORTING_EVENTS
    ADVERTISING
    AGRICULTURAL_SUPPLIES
    BABY_FOODSTUFFS
    BIKES
    BOOKS
    CHILDRENS_CLOTHING
    DOMESTIC_FUEL
    DOMESTIC_SERVICES
    E_BOOKS
    FOODSTUFFS
    HOTELS
    MEDICAL
    NEWSPAPERS
    PASSENGER_TRANSPORT
    PHARMACEUTICALS
    PROPERTY_RENOVATIONS
    RESTAURANTS
    SOCIAL_HOUSING
    STANDARD
    WATER
    WINE
}

"An enumeration."
enum TransactionError {
    "declined"
    TRANSACTIONERROR_DECLINED
    "expired"
    TRANSACTIONERROR_EXPIRED
    "incorrect_address"
    TRANSACTIONERROR_INCORRECT_ADDRESS
    "incorrect_cvv"
    TRANSACTIONERROR_INCORRECT_CVV
    "incorrect_number"
    TRANSACTIONERROR_INCORRECT_NUMBER
    "incorrect_zip"
    TRANSACTIONERROR_INCORRECT_ZIP
    "invalid_cvv"
    TRANSACTIONERROR_INVALID_CVV
    "invalid_expiry_date"
    TRANSACTIONERROR_INVALID_EXPIRY_DATE
    "invalid_number"
    TRANSACTIONERROR_INVALID_NUMBER
    "processing_error"
    TRANSACTIONERROR_PROCESSING_ERROR
}

"An enumeration."
enum TransactionKind {
    "Action to confirm"
    ACTION_TO_CONFIRM
    "Authorization"
    AUTH
    "Cancel"
    CANCEL
    "Capture"
    CAPTURE
    "Confirm"
    CONFIRM
    "Pending"
    PENDING
    "Refund"
    REFUND
    "Refund in progress"
    REFUND_ONGOING
    "Void"
    VOID
}

enum TranslatableKinds {
    ATTRIBUTE
    ATTRIBUTE_VALUE
    CATEGORY
    COLLECTION
    MENU_ITEM
    PAGE
    PRODUCT
    SALE
    SHIPPING_METHOD
    VARIANT
    VOUCHER
}

"An enumeration."
enum TranslationErrorCode {
    GRAPHQL_ERROR
    NOT_FOUND
    REQUIRED
}

enum UserSortField {
    "Sort users by email."
    EMAIL
    "Sort users by first name."
    FIRST_NAME
    "Sort users by last name."
    LAST_NAME
    "Sort users by order count."
    ORDER_COUNT
}

enum VoucherDiscountType {
    FIXED
    PERCENTAGE
    SHIPPING
}

enum VoucherSortField {
    "Sort vouchers by code."
    CODE
    "Sort vouchers by end date."
    END_DATE
    "Sort vouchers by minimum spent amount."
    MINIMUM_SPENT_AMOUNT
    "Sort vouchers by start date."
    START_DATE
    "Sort vouchers by type."
    TYPE
    "Sort vouchers by usage limit."
    USAGE_LIMIT
    "Sort vouchers by value."
    VALUE
}

enum VoucherTypeEnum {
    ENTIRE_ORDER
    SHIPPING
    SPECIFIC_PRODUCT
}

"An enumeration."
enum WarehouseErrorCode {
    ALREADY_EXISTS
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

enum WarehouseSortField {
    "Sort warehouses by name."
    NAME
}

"An enumeration."
enum WebhookErrorCode {
    GRAPHQL_ERROR
    INVALID
    NOT_FOUND
    REQUIRED
    UNIQUE
}

"An enumeration."
enum WebhookEventTypeEnum {
    ANY_EVENTS
    CHECKOUT_CREATED
    CHECKOUT_QUANTITY_CHANGED
    CHECKOUT_UPDATED
    CUSTOMER_CREATED
    FULFILLMENT_CREATED
    INVOICE_DELETED
    INVOICE_REQUESTED
    INVOICE_SENT
    ORDER_CANCELLED
    ORDER_CREATED
    ORDER_FULFILLED
    ORDER_FULLY_PAID
    ORDER_UPDATED
    PRODUCT_CREATED
    PRODUCT_UPDATED
}

"An enumeration."
enum WebhookSampleEventTypeEnum {
    CHECKOUT_CREATED
    CHECKOUT_QUANTITY_CHANGED
    CHECKOUT_UPDATED
    CUSTOMER_CREATED
    FULFILLMENT_CREATED
    INVOICE_DELETED
    INVOICE_REQUESTED
    INVOICE_SENT
    ORDER_CANCELLED
    ORDER_CREATED
    ORDER_FULFILLED
    ORDER_FULLY_PAID
    ORDER_UPDATED
    PRODUCT_CREATED
    PRODUCT_UPDATED
}

enum WebhookSortField {
    "Sort webhooks by service account."
    APP
    "Sort webhooks by name."
    NAME
    "Sort webhooks by service account."
    SERVICE_ACCOUNT
    "Sort webhooks by target url."
    TARGET_URL
}

"An enumeration."
enum WeightUnitsEnum {
    G
    KG
    LB
    OZ
}

input AccountInput {
    "Billing address of the customer."
    defaultBillingAddress: AddressInput
    "Shipping address of the customer."
    defaultShippingAddress: AddressInput
    "Given name."
    firstName: String
    "Family name."
    lastName: String
}

input AccountRegisterInput {
    "The email address of the user."
    email: String!
    "Password."
    password: String!
    "Base of frontend URL that will be needed to create confirmation URL."
    redirectUrl: String
}

input AddressInput {
    "City."
    city: String
    "District."
    cityArea: String
    "Company or organization."
    companyName: String
    "Country."
    country: CountryCode
    "State or province."
    countryArea: String
    "Given name."
    firstName: String
    "Family name."
    lastName: String
    "Phone number."
    phone: String
    "Postal code."
    postalCode: String
    "Address."
    streetAddress1: String
    "Address."
    streetAddress2: String
}

input AppFilterInput {
    isActive: Boolean
    search: String
    type: AppTypeEnum
}

input AppInput {
    "DEPRECATED: Use the `appActivate` and `appDeactivate` mutations instead. This field will be removed after 2020-07-31."
    isActive: Boolean
    "Name of the app."
    name: String
    "List of permission code names to assign to this app."
    permissions: [PermissionEnum]
}

input AppInstallInput {
    "Determine if app will be set active or not."
    activateAfterInstallation: Boolean = true
    "Name of the app to install."
    appName: String
    "Url to app's manifest in JSON format."
    manifestUrl: String
    "List of permission code names to assign to this app."
    permissions: [PermissionEnum]
}

input AppSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort apps by the selected field."
    field: AppSortField!
}

input AppTokenInput {
    "ID of app."
    app: ID!
    "Name of the token."
    name: String
}

input AttributeAssignInput {
    "The ID of the attribute to assign."
    id: ID!
    "The attribute type to be assigned as."
    type: AttributeTypeEnum!
}

input AttributeCreateInput {
    "Whether the attribute can be displayed in the admin product list."
    availableInGrid: Boolean
    "Whether the attribute can be filtered in dashboard."
    filterableInDashboard: Boolean
    "Whether the attribute can be filtered in storefront."
    filterableInStorefront: Boolean
    "The input type to use for entering attribute values in the dashboard."
    inputType: AttributeInputTypeEnum
    "Whether the attribute is for variants only."
    isVariantOnly: Boolean
    "Name of an attribute displayed in the interface."
    name: String!
    "Internal representation of an attribute name."
    slug: String
    "The position of the attribute in the storefront navigation (0 by default)."
    storefrontSearchPosition: Int
    "Whether the attribute requires values to be passed or not."
    valueRequired: Boolean
    "List of attribute's values."
    values: [AttributeValueCreateInput]
    "Whether the attribute should be visible or not in storefront."
    visibleInStorefront: Boolean
}

input AttributeFilterInput {
    availableInGrid: Boolean
    filterableInDashboard: Boolean
    filterableInStorefront: Boolean
    ids: [ID]
    inCategory: ID
    inCollection: ID
    isVariantOnly: Boolean
    search: String
    valueRequired: Boolean
    visibleInStorefront: Boolean
}

input AttributeInput {
    "Internal representation of an attribute name."
    slug: String!
    "[Deprecated] Internal representation of a value (unique per attribute). This field will be removed after 2020-07-31."
    value: String
    "Internal representation of a value (unique per attribute)."
    values: [String]
}

input AttributeSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort attributes by the selected field."
    field: AttributeSortField!
}

input AttributeUpdateInput {
    "New values to be created for this attribute."
    addValues: [AttributeValueCreateInput]
    "Whether the attribute can be displayed in the admin product list."
    availableInGrid: Boolean
    "Whether the attribute can be filtered in dashboard."
    filterableInDashboard: Boolean
    "Whether the attribute can be filtered in storefront."
    filterableInStorefront: Boolean
    "Whether the attribute is for variants only."
    isVariantOnly: Boolean
    "Name of an attribute displayed in the interface."
    name: String
    "IDs of values to be removed from this attribute."
    removeValues: [ID]
    "Internal representation of an attribute name."
    slug: String
    "The position of the attribute in the storefront navigation (0 by default)."
    storefrontSearchPosition: Int
    "Whether the attribute requires values to be passed or not."
    valueRequired: Boolean
    "Whether the attribute should be visible or not in storefront."
    visibleInStorefront: Boolean
}

input AttributeValueCreateInput {
    "Name of a value displayed in the interface."
    name: String!
}

input AttributeValueInput {
    "ID of the selected attribute."
    id: ID
    "The value or slug of an attribute to resolve. If the passed value is non-existent, it will be created."
    values: [String]!
}

input AuthorizationKeyInput {
    "Client authorization key (client ID)."
    key: String!
    "Client secret."
    password: String!
}

input CatalogueInput {
    "Categories related to the discount."
    categories: [ID]
    "Collections related to the discount."
    collections: [ID]
    "Products related to the discount."
    products: [ID]
}

input CategoryFilterInput {
    ids: [ID]
    search: String
}

input CategoryInput {
    "Background image file."
    backgroundImage: Upload
    "Alt text for an image."
    backgroundImageAlt: String
    "Category description (HTML/text)."
    description: String
    "Category description (JSON)."
    descriptionJson: JSONString
    "Category name."
    name: String
    "Search engine optimization fields."
    seo: SeoInput
    "Category slug."
    slug: String
}

input CategorySortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort categories by the selected field."
    field: CategorySortField!
}

input CheckoutCreateInput {
    "Billing address of the customer."
    billingAddress: AddressInput
    "The customer's email address."
    email: String
    "A list of checkout lines, each containing information about an item in the checkout."
    lines: [CheckoutLineInput]!
    "The mailing address to where the checkout will be shipped. Note: the address will be ignored if the checkout doesn't contain shippable items."
    shippingAddress: AddressInput
}

input CheckoutLineInput {
    "The number of items purchased."
    quantity: Int!
    "ID of the product variant."
    variantId: ID!
}

input CollectionCreateInput {
    "Background image file."
    backgroundImage: Upload
    "Alt text for an image."
    backgroundImageAlt: String
    "Description of the collection (HTML/text)."
    description: String
    "Description of the collection (JSON)."
    descriptionJson: JSONString
    "Informs whether a collection is published."
    isPublished: Boolean
    "Name of the collection."
    name: String
    "List of products to be added to the collection."
    products: [ID]
    "Publication date. ISO 8601 standard."
    publicationDate: Date
    "Search engine optimization fields."
    seo: SeoInput
    "Slug of the collection."
    slug: String
}

input CollectionFilterInput {
    ids: [ID]
    published: CollectionPublished
    search: String
}

input CollectionInput {
    "Background image file."
    backgroundImage: Upload
    "Alt text for an image."
    backgroundImageAlt: String
    "Description of the collection (HTML/text)."
    description: String
    "Description of the collection (JSON)."
    descriptionJson: JSONString
    "Informs whether a collection is published."
    isPublished: Boolean
    "Name of the collection."
    name: String
    "Publication date. ISO 8601 standard."
    publicationDate: Date
    "Search engine optimization fields."
    seo: SeoInput
    "Slug of the collection."
    slug: String
}

input CollectionSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort collections by the selected field."
    field: CollectionSortField!
}

input ConfigurationItemInput {
    "Name of the field to update."
    name: String!
    "Value of the given field to update."
    value: String
}

input CustomerFilterInput {
    dateJoined: DateRangeInput
    moneySpent: PriceRangeInput
    numberOfOrders: IntRangeInput
    placedOrders: DateRangeInput
    search: String
}

input CustomerInput {
    "Billing address of the customer."
    defaultBillingAddress: AddressInput
    "Shipping address of the customer."
    defaultShippingAddress: AddressInput
    "The unique email address of the user."
    email: String
    "Given name."
    firstName: String
    "User account is active."
    isActive: Boolean
    "Family name."
    lastName: String
    "A note about the user."
    note: String
}

input DateRangeInput {
    "Start date."
    gte: Date
    "End date."
    lte: Date
}

input DateTimeRangeInput {
    "Start date."
    gte: DateTime
    "End date."
    lte: DateTime
}

input DigitalContentInput {
    "Overwrite default automatic_fulfillment setting for variant."
    automaticFulfillment: Boolean
    "Determines how many times a download link can be accessed by a customer."
    maxDownloads: Int
    "Determines for how many days a download link is active since it was generated."
    urlValidDays: Int
    "Use default digital content settings for this product."
    useDefaultSettings: Boolean!
}

input DigitalContentUploadInput {
    "Overwrite default automatic_fulfillment setting for variant."
    automaticFulfillment: Boolean
    "Represents an file in a multipart request."
    contentFile: Upload!
    "Determines how many times a download link can be accessed by a customer."
    maxDownloads: Int
    "Determines for how many days a download link is active since it was generated."
    urlValidDays: Int
    "Use default digital content settings for this product."
    useDefaultSettings: Boolean!
}

input DigitalContentUrlCreateInput {
    "Digital content ID which URL will belong to."
    content: ID!
}

input DraftOrderCreateInput {
    "Billing address of the customer."
    billingAddress: AddressInput
    "A note from a customer. Visible by customers in the order summary."
    customerNote: String
    "Discount amount for the order."
    discount: PositiveDecimal
    "Variant line input consisting of variant ID and quantity of products."
    lines: [OrderLineCreateInput]
    "Shipping address of the customer."
    shippingAddress: AddressInput
    "ID of a selected shipping method."
    shippingMethod: ID
    user: ID
    "Email address of the customer."
    userEmail: String
    "ID of the voucher associated with the order."
    voucher: ID
}

input DraftOrderInput {
    "Billing address of the customer."
    billingAddress: AddressInput
    "A note from a customer. Visible by customers in the order summary."
    customerNote: String
    "Discount amount for the order."
    discount: PositiveDecimal
    "Shipping address of the customer."
    shippingAddress: AddressInput
    "ID of a selected shipping method."
    shippingMethod: ID
    user: ID
    "Email address of the customer."
    userEmail: String
    "ID of the voucher associated with the order."
    voucher: ID
}

input ExportFileFilterInput {
    app: String
    createdAt: DateTimeRangeInput
    status: JobStatusEnum
    updatedAt: DateTimeRangeInput
    user: String
}

input ExportFileSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort export file by the selected field."
    field: ExportFileSortField!
}

input ExportInfoInput {
    "List of attribute ids witch should be exported."
    attributes: [ID!]
    "List of product fields witch should be exported."
    fields: [ProductFieldEnum!]
    "List of warehouse ids witch should be exported."
    warehouses: [ID!]
}

input ExportProductsInput {
    "Input with info about fields which should be exported."
    exportInfo: ExportInfoInput
    "Type of exported file."
    fileType: FileTypesEnum!
    "Filtering options for products."
    filter: ProductFilterInput
    "List of products IDS to export."
    ids: [ID!]
    "Determine which products should be exported."
    scope: ExportScope!
}

input FulfillmentCancelInput {
    "ID of warehouse where items will be restock."
    warehouseId: ID!
}

input FulfillmentUpdateTrackingInput {
    "If true, send an email notification to the customer."
    notifyCustomer: Boolean = false
    "Fulfillment tracking number."
    trackingNumber: String
}

input GiftCardCreateInput {
    "Value of the gift card."
    balance: PositiveDecimal
    "Code to use the gift card."
    code: String
    "End date of the gift card in ISO 8601 format."
    endDate: Date
    "Start date of the gift card in ISO 8601 format."
    startDate: Date
    "The customer's email of the gift card buyer."
    userEmail: String
}

input GiftCardUpdateInput {
    "Value of the gift card."
    balance: PositiveDecimal
    "End date of the gift card in ISO 8601 format."
    endDate: Date
    "Start date of the gift card in ISO 8601 format."
    startDate: Date
    "The customer's email of the gift card buyer."
    userEmail: String
}

input IntRangeInput {
    "Value greater than or equal to."
    gte: Int
    "Value less than or equal to."
    lte: Int
}

input InvoiceCreateInput {
    "Invoice number."
    number: String!
    "URL of an invoice to download."
    url: String!
}

input MenuCreateInput {
    "List of menu items."
    items: [MenuItemInput]
    "Name of the menu."
    name: String!
    "Slug of the menu. Will be generated if not provided."
    slug: String
}

input MenuFilterInput {
    search: String
    slug: [String]
}

input MenuInput {
    "Name of the menu."
    name: String
    "Slug of the menu."
    slug: String
}

input MenuItemCreateInput {
    "Category to which item points."
    category: ID
    "Collection to which item points."
    collection: ID
    "Menu to which item belongs."
    menu: ID!
    "Name of the menu item."
    name: String!
    "Page to which item points."
    page: ID
    "ID of the parent menu. If empty, menu will be top level menu."
    parent: ID
    "URL of the pointed item."
    url: String
}

input MenuItemFilterInput {
    search: String
}

input MenuItemInput {
    "Category to which item points."
    category: ID
    "Collection to which item points."
    collection: ID
    "Name of the menu item."
    name: String
    "Page to which item points."
    page: ID
    "URL of the pointed item."
    url: String
}

input MenuItemMoveInput {
    "The menu item ID to move."
    itemId: ID!
    "ID of the parent menu. If empty, menu will be top level menu."
    parentId: ID
    "The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged."
    sortOrder: Int
}

input MenuItemSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort menu items by the selected field."
    field: MenuItemsSortField!
}

input MenuSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort menus by the selected field."
    field: MenuSortField!
}

input MetaInput {
    "Metadata client's name."
    clientName: String!
    "Key for stored data."
    key: String!
    "Name of metadata client group."
    namespace: String!
    "Stored metadata value."
    value: String!
}

input MetaPath {
    "Metadata client's name."
    clientName: String!
    "Key for stored data."
    key: String!
    "Name of metadata client group."
    namespace: String!
}

input MetadataInput {
    "Key of a metadata item."
    key: String!
    "Value of a metadata item."
    value: String!
}

input MoveProductInput {
    "The ID of the product to move."
    productId: ID!
    "The relative sorting position of the product (from -inf to +inf) starting from the first given product's actual position.1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged."
    sortOrder: Int
}

input NameTranslationInput {
    name: String
}

input OrderAddNoteInput {
    "Note message."
    message: String!
}

input OrderDraftFilterInput {
    created: DateRangeInput
    customer: String
    search: String
}

input OrderFilterInput {
    created: DateRangeInput
    customer: String
    paymentStatus: [PaymentChargeStatusEnum]
    search: String
    status: [OrderStatusFilter]
}

input OrderFulfillInput {
    "List of items informing how to fulfill the order."
    lines: [OrderFulfillLineInput!]!
    "If true, send an email notification to the customer."
    notifyCustomer: Boolean
}

input OrderFulfillLineInput {
    "The ID of the order line."
    orderLineId: ID
    "List of stock items to create."
    stocks: [OrderFulfillStockInput!]!
}

input OrderFulfillStockInput {
    "The number of line items to be fulfilled from given warehouse."
    quantity: Int!
    "ID of the warehouse from which the item will be fulfilled."
    warehouse: ID!
}

input OrderLineCreateInput {
    "Number of variant items ordered."
    quantity: Int!
    "Product variant ID."
    variantId: ID!
}

input OrderLineInput {
    "Number of variant items ordered."
    quantity: Int!
}

input OrderSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort orders by the selected field."
    field: OrderSortField!
}

input OrderUpdateInput {
    "Billing address of the customer."
    billingAddress: AddressInput
    "Shipping address of the customer."
    shippingAddress: AddressInput
    "Email address of the customer."
    userEmail: String
}

input OrderUpdateShippingInput {
    "ID of the selected shipping method."
    shippingMethod: ID
}

input PageFilterInput {
    search: String
}

input PageInput {
    "Page content. May consist of ordinary text, HTML and images."
    content: String
    "Page content in JSON format."
    contentJson: JSONString
    "Determines if page is visible in the storefront."
    isPublished: Boolean
    "Publication date. ISO 8601 standard."
    publicationDate: String
    "Search engine optimization fields."
    seo: SeoInput
    "Page internal name."
    slug: String
    "Page title."
    title: String
}

input PageSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort pages by the selected field."
    field: PageSortField!
}

input PageTranslationInput {
    content: String
    contentJson: JSONString
    seoDescription: String
    seoTitle: String
    title: String
}

input PaymentInput {
    "Total amount of the transaction, including all taxes and discounts. If no amount is provided, the checkout total will be used."
    amount: PositiveDecimal
    "[Deprecated] Billing address. If empty, the billing address associated with the checkout instance will be used. Use `checkoutCreate` or `checkoutBillingAddressUpdate` mutations to set it. This field will be removed after 2020-07-31."
    billingAddress: AddressInput
    "A gateway to use with that payment."
    gateway: String!
    "URL of a storefront view where user should be redirected after requiring additional actions. Payment with additional actions will not be finished if this field is not provided."
    returnUrl: String
    "Client-side generated payment token, representing customer's billing data in a secure manner."
    token: String
}

input PermissionGroupCreateInput {
    "List of permission code names to assign to this group."
    addPermissions: [PermissionEnum!]
    "List of users to assign to this group."
    addUsers: [ID!]
    "Group name."
    name: String!
}

input PermissionGroupFilterInput {
    search: String
}

input PermissionGroupSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort permission group by the selected field."
    field: PermissionGroupSortField!
}

input PermissionGroupUpdateInput {
    "List of permission code names to assign to this group."
    addPermissions: [PermissionEnum!]
    "List of users to assign to this group."
    addUsers: [ID!]
    "Group name."
    name: String
    "List of permission code names to unassign from this group."
    removePermissions: [PermissionEnum!]
    "List of users to unassign from this group."
    removeUsers: [ID!]
}

input PluginFilterInput {
    active: Boolean
    search: String
}

input PluginSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort plugins by the selected field."
    field: PluginSortField!
}

input PluginUpdateInput {
    "Indicates whether the plugin should be enabled."
    active: Boolean
    "Configuration of the plugin."
    configuration: [ConfigurationItemInput]
}

input PriceRangeInput {
    "Price greater than or equal to."
    gte: Float
    "Price less than or equal to."
    lte: Float
}

input ProductCreateInput {
    "List of attributes."
    attributes: [AttributeValueInput]
    "Default price for product variant. Note: this field is only used if a product doesn't use variants."
    basePrice: PositiveDecimal
    "ID of the product's category."
    category: ID
    "Determine if taxes are being charged for the product."
    chargeTaxes: Boolean
    "List of IDs of collections that the product belongs to."
    collections: [ID]
    "Product description (HTML/text)."
    description: String
    "Product description (JSON)."
    descriptionJson: JSONString
    "Determines if product is visible to customers."
    isPublished: Boolean
    "Product name."
    name: String
    "ID of the type that product belongs to."
    productType: ID!
    "Publication date. ISO 8601 standard."
    publicationDate: Date
    "Search engine optimization fields."
    seo: SeoInput
    "Stock keeping unit of a product. Note: this field is only used if a product doesn't use variants."
    sku: String
    "Product slug."
    slug: String
    "Stocks of a product available for sale. Note: this field is only used if a product doesn't use variants."
    stocks: [StockInput!]
    "Tax rate for enabled tax gateway."
    taxCode: String
    "Determines if the inventory of this product should be tracked. If false, the quantity won't change when customers buy this item. Note: this field is only used if a product doesn't use variants."
    trackInventory: Boolean
    "Determines if product is visible in product listings (doesn't apply to product collections)."
    visibleInListings: Boolean
    "Weight of the Product."
    weight: WeightScalar
}

input ProductFilterInput {
    attributes: [AttributeInput]
    categories: [ID]
    collections: [ID]
    hasCategory: Boolean
    ids: [ID]
    isPublished: Boolean
    minimalPrice: PriceRangeInput
    price: PriceRangeInput
    productType: ID
    productTypes: [ID]
    search: String
    stockAvailability: StockAvailability
    stocks: ProductStockFilterInput
}

input ProductImageCreateInput {
    "Alt text for an image."
    alt: String
    "Represents an image file in a multipart request."
    image: Upload!
    "ID of an product."
    product: ID!
}

input ProductImageUpdateInput {
    "Alt text for an image."
    alt: String
}

input ProductInput {
    "List of attributes."
    attributes: [AttributeValueInput]
    "Default price for product variant. Note: this field is only used if a product doesn't use variants."
    basePrice: PositiveDecimal
    "ID of the product's category."
    category: ID
    "Determine if taxes are being charged for the product."
    chargeTaxes: Boolean
    "List of IDs of collections that the product belongs to."
    collections: [ID]
    "Product description (HTML/text)."
    description: String
    "Product description (JSON)."
    descriptionJson: JSONString
    "Determines if product is visible to customers."
    isPublished: Boolean
    "Product name."
    name: String
    "Publication date. ISO 8601 standard."
    publicationDate: Date
    "Search engine optimization fields."
    seo: SeoInput
    "Stock keeping unit of a product. Note: this field is only used if a product doesn't use variants."
    sku: String
    "Product slug."
    slug: String
    "Tax rate for enabled tax gateway."
    taxCode: String
    "Determines if the inventory of this product should be tracked. If false, the quantity won't change when customers buy this item. Note: this field is only used if a product doesn't use variants."
    trackInventory: Boolean
    "Determines if product is visible in product listings (doesn't apply to product collections)."
    visibleInListings: Boolean
    "Weight of the Product."
    weight: WeightScalar
}

input ProductOrder {
    """

    Sort product by the selected attribute's values.
    Note: this doesn't take translations into account yet.
    """
    attributeId: ID
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort products by the selected field."
    field: ProductOrderField
}

input ProductStockFilterInput {
    quantity: IntRangeInput
    warehouseIds: [ID!]
}

input ProductTypeFilterInput {
    configurable: ProductTypeConfigurable
    ids: [ID]
    productType: ProductTypeEnum
    search: String
}

input ProductTypeInput {
    "Determines if product of this type has multiple variants. This option mainly simplifies product management in the dashboard. There is always at least one variant created under the hood."
    hasVariants: Boolean
    "Determines if products are digital."
    isDigital: Boolean
    "Determines if shipping is required for products of this variant."
    isShippingRequired: Boolean
    "Name of the product type."
    name: String
    "List of attributes shared among all product variants."
    productAttributes: [ID]
    "Product type slug."
    slug: String
    "Tax rate for enabled tax gateway."
    taxCode: String
    "List of attributes used to distinguish between different variants of a product."
    variantAttributes: [ID]
    "Weight of the ProductType items."
    weight: WeightScalar
}

input ProductTypeSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort product types by the selected field."
    field: ProductTypeSortField!
}

input ProductVariantBulkCreateInput {
    "List of attributes specific to this variant."
    attributes: [AttributeValueInput]!
    "Cost price of the variant."
    costPrice: PositiveDecimal
    "Price of the particular variant."
    price: PositiveDecimal
    "Stock keeping unit."
    sku: String!
    "Stocks of a product available for sale."
    stocks: [StockInput!]
    "Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item."
    trackInventory: Boolean
    "Weight of the Product Variant."
    weight: WeightScalar
}

input ProductVariantCreateInput {
    "List of attributes specific to this variant."
    attributes: [AttributeValueInput]!
    "Cost price of the variant."
    costPrice: PositiveDecimal
    "Price of the particular variant."
    price: PositiveDecimal
    "Product ID of which type is the variant."
    product: ID!
    "Stock keeping unit."
    sku: String
    "Stocks of a product available for sale."
    stocks: [StockInput!]
    "Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item."
    trackInventory: Boolean
    "Weight of the Product Variant."
    weight: WeightScalar
}

input ProductVariantFilterInput {
    search: String
    sku: [String]
}

input ProductVariantInput {
    "List of attributes specific to this variant."
    attributes: [AttributeValueInput]
    "Cost price of the variant."
    costPrice: PositiveDecimal
    "Price of the particular variant."
    price: PositiveDecimal
    "Stock keeping unit."
    sku: String
    "Determines if the inventory of this variant should be tracked. If false, the quantity won't change when customers buy this item."
    trackInventory: Boolean
    "Weight of the Product Variant."
    weight: WeightScalar
}

input ReorderInput {
    "The ID of the item to move."
    id: ID!
    "The new relative sorting position of the item (from -inf to +inf). 1 moves the item one position forward, -1 moves the item one position backward, 0 leaves the item unchanged."
    sortOrder: Int
}

input SaleFilterInput {
    saleType: DiscountValueTypeEnum
    search: String
    started: DateTimeRangeInput
    status: [DiscountStatusEnum]
}

input SaleInput {
    "Categories related to the discount."
    categories: [ID]
    "Collections related to the discount."
    collections: [ID]
    "End date of the voucher in ISO 8601 format."
    endDate: DateTime
    "Voucher name."
    name: String
    "Products related to the discount."
    products: [ID]
    "Start date of the voucher in ISO 8601 format."
    startDate: DateTime
    "Fixed or percentage."
    type: DiscountValueTypeEnum
    "Value of the voucher."
    value: PositiveDecimal
}

input SaleSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort sales by the selected field."
    field: SaleSortField!
}

input SeoInput {
    "SEO description."
    description: String
    "SEO title."
    title: String
}

input ServiceAccountFilterInput {
    isActive: Boolean
    search: String
}

input ServiceAccountInput {
    "Determine if this service account should be enabled."
    isActive: Boolean
    "Name of the service account."
    name: String
    "List of permission code names to assign to this service account."
    permissions: [PermissionEnum]
}

input ServiceAccountSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort service accounts by the selected field."
    field: ServiceAccountSortField!
}

input ServiceAccountTokenInput {
    "Name of the token."
    name: String
    "ID of service account."
    serviceAccount: ID!
}

input ShippingPriceInput {
    "Maximum order price to use this shipping method."
    maximumOrderPrice: PositiveDecimal
    "Maximum order weight to use this shipping method."
    maximumOrderWeight: WeightScalar
    "Minimum order price to use this shipping method."
    minimumOrderPrice: PositiveDecimal
    "Minimum order weight to use this shipping method."
    minimumOrderWeight: WeightScalar
    "Name of the shipping method."
    name: String
    "Shipping price of the shipping method."
    price: PositiveDecimal
    "Shipping zone this method belongs to."
    shippingZone: ID
    "Shipping type: price or weight based."
    type: ShippingMethodTypeEnum
}

input ShippingZoneCreateInput {
    "List of warehouses to assign to a shipping zone"
    addWarehouses: [ID]
    "List of countries in this shipping zone."
    countries: [String]
    "Default shipping zone will be used for countries not covered by other zones."
    default: Boolean
    "Shipping zone's name. Visible only to the staff."
    name: String
}

input ShippingZoneUpdateInput {
    "List of warehouses to assign to a shipping zone"
    addWarehouses: [ID]
    "List of countries in this shipping zone."
    countries: [String]
    "Default shipping zone will be used for countries not covered by other zones."
    default: Boolean
    "Shipping zone's name. Visible only to the staff."
    name: String
    "List of warehouses to unassign from a shipping zone"
    removeWarehouses: [ID]
}

input ShopSettingsInput {
    "Enable automatic fulfillment for all digital products."
    automaticFulfillmentDigitalProducts: Boolean
    "Charge taxes on shipping."
    chargeTaxesOnShipping: Boolean
    "URL of a view where customers can set their password."
    customerSetPasswordUrl: String
    "Default number of max downloads per digital content URL."
    defaultDigitalMaxDownloads: Int
    "Default number of days which digital content URL will be valid."
    defaultDigitalUrlValidDays: Int
    "Default email sender's address."
    defaultMailSenderAddress: String
    "Default email sender's name."
    defaultMailSenderName: String
    "Default weight unit."
    defaultWeightUnit: WeightUnitsEnum
    "SEO description."
    description: String
    "Display prices with tax in store."
    displayGrossPrices: Boolean
    "Header text."
    headerText: String
    "Include taxes in prices."
    includeTaxesInPrices: Boolean
    "Enable inventory tracking."
    trackInventoryByDefault: Boolean
}

input ShopSettingsTranslationInput {
    description: String
    headerText: String
}

input SiteDomainInput {
    "Domain name for shop."
    domain: String
    "Shop site name."
    name: String
}

input StaffCreateInput {
    "List of permission group IDs to which user should be assigned."
    addGroups: [ID!]
    "The unique email address of the user."
    email: String
    "Given name."
    firstName: String
    "User account is active."
    isActive: Boolean
    "Family name."
    lastName: String
    "A note about the user."
    note: String
    "URL of a view where users should be redirected to set the password. URL in RFC 1808 format."
    redirectUrl: String
}

input StaffNotificationRecipientInput {
    "Determines if a notification active."
    active: Boolean
    "Email address of a user subscribed to email notifications."
    email: String
    "The ID of the user subscribed to email notifications.."
    user: ID
}

input StaffUpdateInput {
    "List of permission group IDs to which user should be assigned."
    addGroups: [ID!]
    "The unique email address of the user."
    email: String
    "Given name."
    firstName: String
    "User account is active."
    isActive: Boolean
    "Family name."
    lastName: String
    "A note about the user."
    note: String
    "List of permission group IDs from which user should be unassigned."
    removeGroups: [ID!]
}

input StaffUserInput {
    search: String
    status: StaffMemberStatus
}

input StockFilterInput {
    quantity: Float
    search: String
}

input StockInput {
    "Quantity of items available for sell."
    quantity: Int
    "Warehouse in which stock is located."
    warehouse: ID!
}

input TranslationInput {
    description: String
    descriptionJson: JSONString
    name: String
    seoDescription: String
    seoTitle: String
}

input UpdateInvoiceInput {
    "Invoice number"
    number: String
    "URL of an invoice to download."
    url: String
}

input UserCreateInput {
    "Billing address of the customer."
    defaultBillingAddress: AddressInput
    "Shipping address of the customer."
    defaultShippingAddress: AddressInput
    "The unique email address of the user."
    email: String
    "Given name."
    firstName: String
    "User account is active."
    isActive: Boolean
    "Family name."
    lastName: String
    "A note about the user."
    note: String
    "URL of a view where users should be redirected to set the password. URL in RFC 1808 format."
    redirectUrl: String
}

input UserSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort users by the selected field."
    field: UserSortField!
}

input VoucherFilterInput {
    discountType: [VoucherDiscountType]
    search: String
    started: DateTimeRangeInput
    status: [DiscountStatusEnum]
    timesUsed: IntRangeInput
}

input VoucherInput {
    "Voucher should be applied once per customer."
    applyOncePerCustomer: Boolean
    "Voucher should be applied to the cheapest item or entire order."
    applyOncePerOrder: Boolean
    "Categories discounted by the voucher."
    categories: [ID]
    "Code to use the voucher."
    code: String
    "Collections discounted by the voucher."
    collections: [ID]
    "Country codes that can be used with the shipping voucher."
    countries: [String]
    "Value of the voucher."
    discountValue: PositiveDecimal
    "Choices: fixed or percentage."
    discountValueType: DiscountValueTypeEnum
    "End date of the voucher in ISO 8601 format."
    endDate: DateTime
    "Min purchase amount required to apply the voucher."
    minAmountSpent: PositiveDecimal
    "Minimal quantity of checkout items required to apply the voucher."
    minCheckoutItemsQuantity: Int
    "Voucher name."
    name: String
    "Products discounted by the voucher."
    products: [ID]
    "Start date of the voucher in ISO 8601 format."
    startDate: DateTime
    "Voucher type: PRODUCT, CATEGORY SHIPPING or ENTIRE_ORDER."
    type: VoucherTypeEnum
    "Limit number of times this voucher can be used in total."
    usageLimit: Int
}

input VoucherSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort vouchers by the selected field."
    field: VoucherSortField!
}

input WarehouseAddressInput {
    "City."
    city: String!
    "District."
    cityArea: String
    "Country."
    country: CountryCode!
    "State or province."
    countryArea: String
    "Phone number."
    phone: String
    "Postal code."
    postalCode: String
    "Address."
    streetAddress1: String!
    "Address."
    streetAddress2: String
}

input WarehouseCreateInput {
    "Address of the warehouse."
    address: WarehouseAddressInput!
    "Company name."
    companyName: String
    "The email address of the warehouse."
    email: String
    "Warehouse name."
    name: String!
    "Shipping zones supported by the warehouse."
    shippingZones: [ID]
    "Warehouse slug."
    slug: String
}

input WarehouseFilterInput {
    ids: [ID]
    search: String
}

input WarehouseSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort warehouses by the selected field."
    field: WarehouseSortField!
}

input WarehouseUpdateInput {
    "Address of the warehouse."
    address: WarehouseAddressInput
    "Company name."
    companyName: String
    "The email address of the warehouse."
    email: String
    "Warehouse name."
    name: String
    "Warehouse slug."
    slug: String
}

input WebhookCreateInput {
    "ID of the app to which webhook belongs."
    app: ID
    "The events that webhook wants to subscribe. The CHECKOUT_QUANTITY_CHANGED is depreacted. It will be removed in Saleor 3.0"
    events: [WebhookEventTypeEnum]
    "Determine if webhook will be set active or not."
    isActive: Boolean
    "The name of the webhook."
    name: String
    "The secret key used to create a hash signature with each payload."
    secretKey: String
    "DEPRECATED: Use the `app` field instead. This field will be removed after 2020-07-31."
    serviceAccount: ID
    "The url to receive the payload."
    targetUrl: String
}

input WebhookFilterInput {
    isActive: Boolean
    search: String
}

input WebhookSortingInput {
    "Specifies the direction in which to sort products."
    direction: OrderDirection!
    "Sort webhooks by the selected field."
    field: WebhookSortField!
}

input WebhookUpdateInput {
    "ID of the app to which webhook belongs."
    app: ID
    "The events that webhook wants to subscribe. The CHECKOUT_QUANTITY_CHANGED is depreacted. It will be removed in Saleor 3.0"
    events: [WebhookEventTypeEnum]
    "Determine if webhook will be set active or not."
    isActive: Boolean
    "The new name of the webhook."
    name: String
    "Use to create a hash signature with each payload."
    secretKey: String
    "DEPRECATED: Use the `app` field instead. This field will be removed after 2020-07-31."
    serviceAccount: ID
    "The url to receive the payload."
    targetUrl: String
}


"""
The `DateTime` scalar type represents a DateTime
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar DateTime

"""
Allows use of a JSON String for input / output from the GraphQL schema.

Use of this type is *not recommended* as you lose the benefits of having a defined, static
schema (one of the key benefits of GraphQL).
"""
scalar JSONString

"""
The `Date` scalar type represents a Date
value as specified by
[iso8601](https://en.wikipedia.org/wiki/ISO_8601).
"""
scalar Date

scalar UUID

"Anything"
scalar _Any

"""
Positive Decimal scalar implementation.

Should be used in places where value must be positive.
"""
scalar PositiveDecimal

scalar WeightScalar

"Variables of this type must be set to null in mutations. They will be replaced with a filename from a following multipart part containing a binary file. See: https://github.com/jaydenseric/graphql-multipart-request-spec."
scalar Upload

"""
The `GenericScalar` scalar type represents a generic
GraphQL scalar value that could be:
String, Boolean, Int, Float, List or Object.
"""
scalar GenericScalar
